@article{hage_solved_2020,
	title = {Solved and Open Problems in Type Error Diagnosis},
	abstract = {The purpose of this paper is to present a number of directions for future research in type error diagnosis. To be able to position these open problems, we ﬁrst discuss accomplishments in the ﬁeld without trying to be exhaustive.},
	pages = {13},
	author = {Hage, Jurriaan},
	year = {2020},
	date = {2020},
	langid = {english},
	file = {Hage - Solved and Open Problems in Type Error Diagnosis.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\57IM6FAP\\Hage - Solved and Open Problems in Type Error Diagnosis.pdf:application/pdf},
}

@article{crichton_role_2021,
	title = {The Role of Working Memory in Program Tracing},
	url = {http://arxiv.org/abs/2101.06305},
	doi = {10.1145/3411764.3445257},
	abstract = {Program tracing, or mentally simulating a program on concrete inputs, is an important part of general program comprehension. Programs involve many kinds of virtual state that must be held in memory, such as variable/value pairs and a call stack. In this work, we examine the influence of short-term working memory ({WM}) on a person's ability to remember program state during tracing. We first confirm that previous findings in cognitive psychology transfer to the programming domain: people can keep about 7 variable/value pairs in {WM}, and people will accidentally swap associations between variables due to {WM} load. We use a restricted focus viewing interface to further analyze the strategies people use to trace through programs, and the relationship of tracing strategy to {WM}. Given a straight-line program, we find half of our participants traced a program from the top-down line-by-line (linearly), and the other half start at the bottom and trace upward based on data dependencies (on-demand). Participants with an on-demand strategy made more {WM} errors while tracing straight-line code than with a linear strategy, but the two strategies contained an equal number of {WM} errors when tracing code with functions. We conclude with the implications of these findings for the design of programming tools: first, programs should be analyzed to identify and refactor human-memory-intensive sections of code. Second, programming environments should interactively visualize variable metadata to reduce {WM} load in accordance with a person's tracing strategy. Third, tools for program comprehension should enable externalizing program state while tracing.},
	journaltitle = {{arXiv}:2101.06305 [cs]},
	author = {Crichton, Will and Agrawala, Maneesh and Hanrahan, Pat},
	urldate = {2021-01-20},
	year = {2021},
	date = {2021-01-15},
	eprinttype = {arxiv},
	eprint = {2101.06305},
	keywords = {Computer Science - Human-Computer Interaction},
	file = {arXiv Fulltext PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\X68EQS9A\\Crichton et al. - 2021 - The Role of Working Memory in Program Tracing.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\W4XUTN47\\2101.html:text/html},
}

@inproceedings{becker_effective_2016,
	location = {Memphis Tennessee {USA}},
	title = {An Effective Approach to Enhancing Compiler Error Messages},
	isbn = {978-1-4503-3685-7},
	url = {https://dl.acm.org/doi/10.1145/2839509.2844584},
	doi = {10.1145/2839509.2844584},
	abstract = {One of the many challenges novice programmers face from the time they write their ﬁrst program is inadequate compiler error messages. These messages report details on errors the programmer has made and are the only feedback the programmer gets from the compiler. For students they play a particularly essential role as students often have little experience to draw upon, leaving compiler error messages as their primary guidance on error correction. However these messages are frequently inadequate, presenting a barrier to progress and are often a source of discouragement. We have designed and implemented an editor that provides enhanced compiler error messages and conducted a controlled empirical study with {CS}1 students learning Java. We ﬁnd a reduced frequency of overall errors and errors per student. We also identify eight frequent compiler error messages for which enhancement has a statistically signiﬁcant eﬀect. Finally we ﬁnd a reduced number of repeated errors. These ﬁndings indicate fewer students struggling with compiler error messages.},
	eventtitle = {{SIGCSE} '16: The 47th {ACM} Technical Symposium on Computing Science Education},
	pages = {126--131},
	booktitle = {Proceedings of the 47th {ACM} Technical Symposium on Computing Science Education},
	publisher = {{ACM}},
	author = {Becker, Brett A.},
	urldate = {2021-05-21},
	year = {2016},
	date = {2016-02-17},
	langid = {english},
	file = {Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\YS373YTK\\Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:application/pdf},
}

@inproceedings{barik_how_2018,
	title = {How should compilers explain problems to developers?},
	pages = {633--643},
	booktitle = {Proceedings of the 2018 26th {ACM} Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	author = {Barik, Titus and Ford, Denae and Murphy-Hill, Emerson and Parnin, Chris},
	year = {2018},
	date = {2018},
	file = {barik_fse18.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\J76K3M45\\barik_fse18.pdf:application/pdf},
}

@inproceedings{hartmann_what_2010,
	location = {New York, {NY}, {USA}},
	title = {What would other programmers do: suggesting solutions to error messages},
	isbn = {978-1-60558-929-9},
	url = {https://doi.org/10.1145/1753326.1753478},
	doi = {10.1145/1753326.1753478},
	series = {{CHI} '10},
	shorttitle = {What would other programmers do},
	abstract = {Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces {HelpMeOut}, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. {HelpMeOut} comprises {IDE} instrumentation to collect examples of code changes that fix errors; a central database that stores fix reports from many users; and a suggestion interface that, given an error, queries the database for a list of relevant fixes and presents these to the programmer. We report on implementations of this architecture for two programming languages. An evaluation with novice programmers found that the technique can suggest useful fixes for 47\% of errors after 39 person-hours of programming in an instrumented environment.},
	pages = {1019--1028},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Hartmann, Björn and {MacDougall}, Daniel and Brandt, Joel and Klemmer, Scott R.},
	urldate = {2022-11-27},
	year = {2010},
	date = {2010-04-10},
	keywords = {debugging, recommender systems},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\DZHWAZNI\\Hartmann et al. - 2010 - What would other programmers do suggesting soluti.pdf:application/pdf},
}

@inproceedings{uchida_c-helper_2016,
	location = {Setubal, {PRT}},
	title = {C-Helper: C Latent-error Static/Heuristic Checker for Novice Programmers},
	isbn = {978-989-758-179-3},
	url = {https://doi.org/10.5220/0005797703210329},
	doi = {10.5220/0005797703210329},
	series = {{CSEDU} 2016},
	shorttitle = {C-Helper},
	abstract = {For better programming language education, it is crucial to make compiler warning messages more understandable for novice programmers. Unfortunately, however, Kojimaâ s research showed warning messages in commercial-level compilers like {GCC} are still difficult to understand, and the commercial-level compilers tend not to emit how to modify programs to correct the problems. Furthermore, we found that they also tend not to handle latent errors. To solve this problem, by using a heuristic approach, we propose a novel C static checker called C-Helper, that aims to emit more direct error messages understandable for novices to correct wrong programs, and also aims to handle latent errors. Our preliminary evaluation shows that C-Helper was positively evaluated, although our heuristic approach increased false-positives.},
	pages = {321--329},
	booktitle = {Proceedings of the 8th International Conference on Computer Supported Education},
	publisher = {{SCITEPRESS} - Science and Technology Publications, Lda},
	author = {Uchida, Kota and Gondow, Katsuhiko},
	urldate = {2022-11-28},
	year = {2016},
	date = {2016-04-21},
	keywords = {C Static Checker, Compiler Warning Messages, Heuristics, Latent Errors, Novice Programmer., Programming Education},
	file = {Submitted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\4CP9WV5Z\\Uchida and Gondow - 2016 - C-Helper C Latent-error StaticHeuristic Checker .pdf:application/pdf},
}

@inproceedings{watson_bluefix_2012,
	location = {Berlin, Heidelberg},
	title = {{BlueFix}: Using Crowd-Sourced Feedback to Support Programming Students in Error Diagnosis and Repair},
	isbn = {978-3-642-33642-3},
	doi = {10.1007/978-3-642-33642-3_25},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{BlueFix}},
	abstract = {Feedback is regarded as one of the most important influences on student learning and motivation. But standard compiler feedback is designed for experts - not novice programming students, who can find it difficult to interpret and understand. In this paper we present {BlueFix}, an online tool currently integrated into the {BlueJ} {IDE} which is designed to assist programming students with error diagnosis and repair. Unlike existing approaches, {BlueFix} proposes a feedback algorithm based upon frameworks combined from the {HCI} and Pedagogical domains, which can provide different students with dynamic levels of support based upon their compilation behaviour. An evaluation revealed that students’ viewed our tool positively and that our methodology could identify appropriate fixes for uncompilable source code with a significantly higher rate of speed and precision over related techniques in the literature.},
	pages = {228--239},
	booktitle = {Advances in Web-Based Learning - {ICWL} 2012},
	publisher = {Springer},
	author = {Watson, Christopher and Li, Frederick W. B. and Godwin, Jamie L.},
	editor = {Popescu, Elvira and Li, Qing and Klamma, Ralf and Leung, Howard and Specht, Marcus},
	year = {2012},
	date = {2012},
	langid = {english},
	keywords = {Programming Education, Compiler Errors, Crowd Fixes, Feedback},
	file = {Accepted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\XXB27MDH\\Watson et al. - 2012 - BlueFix Using Crowd-Sourced Feedback to Support P.pdf:application/pdf},
}

@article{wu_how_2017,
	title = {How type errors were fixed and what students did?},
	volume = {1},
	url = {https://doi.org/10.1145/3133929},
	doi = {10.1145/3133929},
	abstract = {Providing better supports for debugging type errors has been an active research area in the last three decades. Numerous approaches from different perspectives have been developed. Most approaches work well under certain conditions only, for example, when type errors are caused by single leaves and when type annotations are correct. However, the research community is still unaware of which conditions hold in practice and what the real debugging situations look like. We address this problem with a study of 3 program data sets, which were written in different years, using different compilers, and were of diverse sizes. They include more than 55,000 programs, among which more than 2,700 are ill typed. We investigated all the ill-typed programs, and our results indicate that current error debugging support is far from sufficient in practice since only about 35\% of all type errors were caused by single leaves. In addition, type annotations cannot always be trusted in error debuggers since about 30\% of the time type errors were caused by wrong type annotations. Our study also provides many insights about the debugging behaviors of students in functional programming, which could be exploited for developing more effective error debuggers.},
	pages = {105:1--105:27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Wu, Baijun and Chen, Sheng},
	urldate = {2022-11-28},
	year = {2017},
	date = {2017-10-12},
	keywords = {type inference, empirical study, Type-error debugging},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\2WB5DVYJ\\Wu and Chen - 2017 - How type errors were fixed and what students did.pdf:application/pdf},
}

@article{chen_efficient_2020,
	title = {Efficient counter-factual type error debugging},
	volume = {200},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642320301520},
	doi = {10.1016/j.scico.2020.102544},
	abstract = {Providing effective error messages in response to type errors continues to be a challenge in functional programming. Type error messages often point to bogus error locations or lack sufficient information for removing the type error, making error debugging ineffective. Counter-factual typing ({CFT}) addressed this problem by generating comprehensive error messages with each message includes a rich set of information. However, this comes with a cost of huge computations, making it too slow for interactive use. In particular, our recent study shows that programmers usually have to go through multiple iterations of updating and recompiling programs to remove a type error. Interestingly, our study also finds that program updates are minor in each iteration during type error debugging. We exploit this fact and develop {eCFT}, an efficient version of {CFT}, which doesn't recompute all error fixes from scratch for each updated program but only recomputes error fixes that are changed in response to the update. Our key observation is that minor program changes lead to minor error suggestion changes. {eCFT} is based on principal typing, a typing scheme more amenable to reuse previous typing results. We have evaluated our approach and found it is about 12.4× faster than {CFT} in updating error fixes.},
	pages = {102544},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Chen, Sheng and Wu, Baijun},
	urldate = {2022-11-28},
	year = {2020},
	date = {2020-12-01},
	langid = {english},
	keywords = {Efficient type-error debugging, Principal typing, Variational typing},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\YSRLHV7Q\\Chen and Wu - 2020 - Efficient counter-factual type error debugging.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\RATV7C6T\\S0167642320301520.html:text/html},
}

@inproceedings{potter_hazel_2020,
	title = {Hazel Tutor: Guiding Novices Through Type-Driven Development Strategies},
	eventtitle = {Human Aspects of Types and Reasoning Assistants},
	pages = {10},
	author = {Potter, Hannah and Omar, Cyrus},
	year = {2020},
	date = {2020},
	langid = {english},
	file = {Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\NWG4MUL7\\Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:application/pdf},
}

@misc{leinonen_using_2022,
	title = {Using Large Language Models to Enhance Programming Error Messages},
	url = {http://arxiv.org/abs/2210.11630},
	doi = {10.48550/arXiv.2210.11630},
	abstract = {A key part of learning to program is learning to understand programming error messages. They can be hard to interpret and identifying the cause of errors can be time-consuming. One factor in this challenge is that the messages are typically intended for an audience that already knows how to program, or even for programming environments that then use the information to highlight areas in code. Researchers have been working on making these errors more novice friendly since the 1960s, however progress has been slow. The present work contributes to this stream of research by using large language models to enhance programming error messages with explanations of the errors and suggestions on how to fix the error. Large language models can be used to create useful and novice-friendly enhancements to programming error messages that sometimes surpass the original programming error messages in interpretability and actionability. These results provide further evidence of the benefits of large language models for computing educators, highlighting their use in areas known to be challenging for students. We further discuss the benefits and downsides of large language models and highlight future streams of research for enhancing programming error messages.},
	number = {{arXiv}:2210.11630},
	publisher = {{arXiv}},
	author = {Leinonen, Juho and Hellas, Arto and Sarsa, Sami and Reeves, Brent and Denny, Paul and Prather, James and Becker, Brett A.},
	urldate = {2022-11-28},
	year = {2022},
	date = {2022-10-20},
	eprinttype = {arxiv},
	eprint = {2210.11630 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Artificial Intelligence, Computer Science - Computation and Language, Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\AWNXRMLQ\\Leinonen et al. - 2022 - Using Large Language Models to Enhance Programming.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\H5BUETBU\\2210.html:text/html},
}

@inproceedings{prather_novices_2017,
	location = {New York, {NY}, {USA}},
	title = {On Novices' Interaction with Compiler Error Messages: A Human Factors Approach},
	isbn = {978-1-4503-4968-0},
	url = {https://doi.org/10.1145/3105726.3106169},
	doi = {10.1145/3105726.3106169},
	series = {{ICER} '17},
	shorttitle = {On Novices' Interaction with Compiler Error Messages},
	abstract = {The difficulty in understanding compiler error messages can be a major impediment to novice student learning. To alleviate this issue, multiple researchers have run experiments enhancing compiler error messages in automated assessment tools for programming assignments. The conclusions reached by these published experiments appear to be conducting. We examine these experiments and propose five potential reasons for the inconsistent conclusions concerning enhanced compiler error messages: (1) students do not read them, (2) researchers are measuring the wrong thing, (3) the effects are hard to measure, (4) the messages are not properly designed, (5) the messages are properly designed, but students do not understand them in context due to increased cognitive load. We constructed mixed-methods experiments designed to address reasons 1 and 5 with a specific automated assessment tool, Athene, that previously reported inconclusive results. Testing student comprehension of the enhanced compiler error messages outside the context of an automated assessment tool demonstrated their effectiveness over standard compiler error messages. Quantitative results from a 60 minute one-on-one think-aloud study with 31 students did not show substantial increase in student learning outcomes over the control. However, qualitative results from the one-on-one think-aloud study indicated that most students are reading the enhanced compiler error messages and generally make effective changes after encountering them.},
	pages = {74--82},
	booktitle = {Proceedings of the 2017 {ACM} Conference on International Computing Education Research},
	publisher = {Association for Computing Machinery},
	author = {Prather, James and Pettit, Raymond and {McMurry}, Kayla Holcomb and Peters, Alani and Homer, John and Simone, Nevan and Cohen, Maxine},
	urldate = {2022-11-28},
	year = {2017},
	date = {2017-08-14},
	keywords = {{CS}1, {HCI}, automated assessment tools, education, ethnography, human factors, usability},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\FYLNZ4FY\\Prather et al. - 2017 - On Novices' Interaction with Compiler Error Messag.pdf:application/pdf},
}

@inproceedings{barik_developers_2017,
	location = {Buenos Aires, Argentina},
	title = {Do developers read compiler error messages?},
	isbn = {978-1-5386-3868-2},
	url = {https://doi.org/10.1109/ICSE.2017.59},
	doi = {10.1109/ICSE.2017.59},
	series = {{ICSE} '17},
	abstract = {In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13\%--25\%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.},
	pages = {575--585},
	booktitle = {Proceedings of the 39th International Conference on Software Engineering},
	publisher = {{IEEE} Press},
	author = {Barik, Titus and Smith, Justin and Lubick, Kevin and Holmes, Elisabeth and Feng, Jing and Murphy-Hill, Emerson and Parnin, Chris},
	urldate = {2022-11-28},
	year = {2017},
	date = {2017-05-20},
	keywords = {compiler errors, eye tracking, integrated development environments, programmer comprehension, reading, visual attention},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\QZMS6ZMH\\Barik et al. - 2017 - Do developers read compiler error messages.pdf:application/pdf},
}

@inproceedings{chen_empirical_2020,
	location = {New York, {NY}, {USA}},
	title = {An Empirical Study on Dynamic Typing Related Practices in Python Systems},
	isbn = {978-1-4503-7958-8},
	url = {https://doi.org/10.1145/3387904.3389253},
	doi = {10.1145/3387904.3389253},
	series = {{ICPC} '20},
	abstract = {The dynamic typing discipline of Python allows developers to program at a high level of abstraction. However, type related bugs are commonly encountered in Python systems due to the lack of type declaration and static type checking. Especially, the misuse of dynamic typing discipline produces underlying bugs and increases maintenance efforts. In this paper, we introduce six types of dynamic typing related practices in Python programs, which are the common but potentially risky usage of dynamic typing discipline by developers. We also implement a tool named {PYDYPE} to detect them. Based on this tool, we conduct an empirical study on nine real-world Python systems (with the size of more than 460KLOC) to understand dynamic typing related practices. We investigate how widespread the dynamic typing related practices are, why they are introduced into the systems, whether their usage correlates with increased likelihood of bug occurring, and how developers fix dynamic typing related bugs. The results show that: (1) dynamic typing related practices exist inconsistently in different systems and Inconsistent Variable Types is most prevalent; (2) they are introduced into systems mainly during early development phase to promote development efficiency; (3) they have a significant positive correlation with bug occurring; (4) developers tend to add type checks or exception handling to fix dynamic typing related bugs. These results benefit future research in coding convention, language design, bug detection and fixing.},
	pages = {83--93},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {Association for Computing Machinery},
	author = {Chen, Zhifei and Li, Yanhui and Chen, Bihuan and Ma, Wanwangying and Chen, Lin and Xu, Baowen},
	urldate = {2022-11-28},
	year = {2020},
	date = {2020-09-12},
	keywords = {empirical study, dynamic typing, Python},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\B5GFRWHC\\Chen et al. - 2020 - An Empirical Study on Dynamic Typing Related Pract.pdf:application/pdf},
}

@inproceedings{peitek_what_2020,
	location = {Seoul Republic of Korea},
	title = {What Drives the Reading Order of Programmers?: An Eye Tracking Study},
	isbn = {978-1-4503-7958-8},
	url = {https://dl.acm.org/doi/10.1145/3387904.3389279},
	doi = {10.1145/3387904.3389279},
	shorttitle = {What Drives the Reading Order of Programmers?},
	abstract = {Background: The way how programmers comprehend source code depends on several factors, including the source code itself and the programmer. Recent studies showed that novice programmers tend to read source code more like natural language text, whereas experts tend to follow the program execution flow. But, it is unknown how the linearity of source code and the comprehension strategy influence programmers’ linearity of reading order.},
	eventtitle = {{ICPC} '20: 28th International Conference on Program Comprehension},
	pages = {342--353},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Peitek, Norman and Siegmund, Janet and Apel, Sven},
	urldate = {2022-11-28},
	year = {2020},
	date = {2020-07-13},
	langid = {english},
	file = {Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\5P68H8QU\\Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:application/pdf},
}

@inproceedings{tymchuk_jit_2018,
	location = {Gothenburg Sweden},
	title = {{JIT} feedback: what experienced developers like about static analysis},
	isbn = {978-1-4503-5714-2},
	url = {https://dl.acm.org/doi/10.1145/3196321.3196327},
	doi = {10.1145/3196321.3196327},
	shorttitle = {{JIT} feedback},
	abstract = {Although software developers are usually reluctant to use static analysis to detect issues in their source code, our automatic justin-time static analysis assistant was integrated into an Integrated Development Environment, and was evaluated positively by its users. We conducted interviews to understand the impact of the tool on experienced developers, and how it performs in comparison with other static analyzers.},
	eventtitle = {{ICSE} '18: 40th International Conference on Software Engineering},
	pages = {64--73},
	booktitle = {Proceedings of the 26th Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Tymchuk, Yuriy and Ghafari, Mohammad and Nierstrasz, Oscar},
	urldate = {2022-11-28},
	year = {2018},
	date = {2018-05-28},
	langid = {english},
	file = {Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\UPLMXZNT\\Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:application/pdf},
}

@article{tirronen_understanding_2015,
	title = {Understanding beginners' mistakes with Haskell},
	volume = {25},
	issn = {0956-7968, 1469-7653},
	doi = {10.1017/S0956796815000179},
	abstract = {This article presents an overview of student difficulties in an introductory functional programming ({FP}) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to {FP} languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
	pages = {e11},
	journaltitle = {Journal of Functional Programming},
	author = {Tirronen, Ville and Uusi-Mäkelä, Samuel and Isomöttönen, Ville},
	urldate = {2022-11-30},
	year = {2015},
	date = {2015},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\CVGTHT3I\\Tirronen et al. - 2015 - Understanding beginners' mistakes with Haskell.pdf:application/pdf;Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\PX3IZ8M4\\244DB6807F3BD77E14CE7D627514D6D3.html:text/html},
}

@book{jakob_nielsen_usability_1993,
	title = {Usability Engineering},
	publisher = {Morgan Kaufmann},
	author = {{Jakob Nielsen}},
	year = {1993},
	date = {1993},
}

@online{stackoverflow_stack_2022,
	title = {Stack Overflow Developer Survey 2022},
	url = {https://survey.stackoverflow.co/2022/},
	abstract = {In May 2022 over 70,000 developers told us how they learn and level up, which tools they’re using, and what they want.},
	titleaddon = {Stack Overflow},
	author = {{StackOverflow}},
	urldate = {2022-11-30},
	year = {2022},
	date = {2022},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\6JVDBGSQ\\2022.html:text/html},
}

@online{github_github_2022,
	title = {{GitHub} Topic: Haskell},
	url = {https://github.com/topics/haskell},
	abstract = {{GitHub} is where people build software. More than 94 million people use {GitHub} to discover, fork, and contribute to over 330 million projects.},
	titleaddon = {{GitHub}},
	author = {{Github}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\I9YMPF7L\\haskell.html:text/html},
}

@inproceedings{chen_improving_2022,
	location = {Cham},
	title = {Improving Type Error Reporting for Type Classes},
	isbn = {978-3-030-99461-7},
	doi = {10.1007/978-3-030-99461-7_2},
	series = {Lecture Notes in Computer Science},
	abstract = {Debugging type errors when type inference fails is a challenging problem since there are many different ways to remove the type error, and it’s unclear which way is intended. While numerous approaches have been proposed to more precisely locate the real error causes, most of them do not deal with popular type system extensions, such as type classes. A second problem is that most approaches do not provide enough information for removing the type error or do so for a few error causes only.},
	pages = {19--38},
	booktitle = {Functional and Logic Programming},
	publisher = {Springer International Publishing},
	author = {Chen, Sheng and Noor, Md Rabib},
	editor = {Hanus, Michael and Igarashi, Atsushi},
	year = {2022},
	date = {2022},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\S49WNG7Q\\Chen and Noor - 2022 - Improving Type Error Reporting for Type Classes.pdf:application/pdf},
}

@online{openreplay_openreplay_2022,
	title = {{OpenReplay}: Open-Source Session Replay},
	url = {https://openreplay.com/},
	author = {{OpenReplay}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
}

@online{oracle_generic_2022,
	title = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials {\textgreater} Learning the Java Language {\textgreater} Generics (Updated))},
	url = {https://docs.oracle.com/javase/tutorial/java/generics/boundedTypeParams.html},
	author = {{Oracle}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	file = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials > Learning the Java Language > Generics (Updated)):C\:\\Users\\sfuu0016\\Zotero\\storage\\N4IGCP5E\\boundedTypeParams.html:text/html},
}

@online{bill_wagner_constraints_2022,
	title = {Constraints on type parameters - C\# Programming Guide},
	url = {https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters},
	abstract = {Learn about constraints on type parameters. Constraints tell the compiler what capabilities a type argument must have.},
	author = {{Bill Wagner}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	langid = {english},
}

@inproceedings{pavlinovic_practical_2015,
	location = {New York, {NY}, {USA}},
	title = {Practical {SMT}-based type error localization},
	isbn = {978-1-4503-3669-7},
	url = {https://doi.org/10.1145/2784731.2784765},
	doi = {10.1145/2784731.2784765},
	series = {{ICFP} 2015},
	abstract = {Compilers for statically typed functional programming languages are notorious for generating confusing type error messages. When the compiler detects a type error, it typically reports the program location where the type checking failed as the source of the error. Since other error sources are not even considered, the actual root cause is often missed. A more adequate approach is to consider all possible error sources and report the most useful one subject to some usefulness criterion. In our previous work, we showed that this approach can be formulated as an optimization problem related to satisfiability modulo theories ({SMT}). This formulation cleanly separates the heuristic nature of usefulness criteria from the underlying search problem. Unfortunately, algorithms that search for an optimal error source cannot directly use principal types which are crucial for dealing with the exponential-time complexity of the decision problem of polymorphic type checking. In this paper, we present a new algorithm that efficiently finds an optimal error source in a given ill-typed program. Our algorithm uses an improved {SMT} encoding to cope with the high complexity of polymorphic typing by iteratively expanding the typing constraints from which principal types are derived. The algorithm preserves the clean separation between the heuristics and the actual search. We have implemented our algorithm for {OCaml}. In our experimental evaluation, we found that the algorithm reduces the running times for optimal type error localization from minutes to seconds and scales better than previous localization algorithms.},
	pages = {412--423},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {Association for Computing Machinery},
	author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
	urldate = {2022-12-02},
	year = {2015},
	date = {2015-08-29},
	keywords = {Polymorphic Types, Satisfiability Modulo Theories, Type Error Localization},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\DT9YHB5D\\Pavlinovic et al. - 2015 - Practical SMT-based type error localization.pdf:application/pdf},
}

@online{microsoft_documentation_2022,
	title = {Documentation - Generics},
	url = {https://www.typescriptlang.org/docs/handbook/2/generics.html},
	abstract = {Types which take parameters},
	author = {{Microsoft}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	langid = {english},
}

@online{anonymous_chameleon_2022,
	title = {Chameleon Type Debugger},
	url = {https://chameleon.typecheck.me/},
	author = {{Fu, Shuai}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	file = {Chameleon Type Debugger:C\:\\Users\\sfuu0016\\Zotero\\storage\\7ABZKGSA\\chameleon.typecheck.me.html:text/html},
}

@online{ben_gamari_home_2022,
	title = {Home — The Glasgow Haskell Compiler},
	url = {https://www.haskell.org/ghc/},
	author = {{Ben Gamari}},
	urldate = {2022-12-01},
	year = {2022},
	date = {2022},
	file = {Home — The Glasgow Haskell Compiler:C\:\\Users\\sfuu0016\\Zotero\\storage\\KQPULY88\\ghc.html:text/html},
}

@article{mayer_static_2012,
	title = {Static Type Systems (Sometimes) have a Positive Impact on the Usability of Undocumented Software: An Empirical Evaluation},
	abstract = {Static and dynamic type systems (as well as more recently gradual type systems) are an important research topic in programming language design. Although the study of such systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease ﬂexibility, which may make them harder to use. While positions such as these, both for and against static type systems, have been documented in the literature, there is little rigorous empirical evidence for or against either position. In this paper, we introduce a controlled experiment where 27 subjects performed programming tasks on an undocumented {API} with a static type system (which required type annotations) as well as a dynamic type system (which does not). Our results show that for some types of tasks, programmers were afforded faster task completion times using a static type system, while for others, the opposite held. In this work, we document the empirical evidence that led us to this conclusion and conduct an exploratory study to try and theorize why.},
	pages = {20},
	author = {Mayer, Clemens and Robbes, Romain and Tanter, Éric and Steﬁk, Andreas},
	year = {2012},
	date = {2012},
	langid = {english},
	file = {Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\PR85XC8Y\\Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:application/pdf},
}

@article{jun_explaining_2002,
	title = {Explaining Polymorphic Types},
	volume = {45},
	doi = {10.1093/comjnl/45.4.436},
	abstract = {Polymorphic types in programming languages facilitate code reuse, increase reliability and reduce semantic errors in programs. Hindley-Milner type inference forms a strong basis for checking polymorphic types but is less well suited to explaining them, as it introduces intermediate constructs that relate poorly to a programmer’s understanding of the program. We report an experiment into expert human type explanation and uncover a simple set of rules for human-like explanations. We present a type explanation system based on these rules rather than Hindley-Milner inference. The system uses a new ℋ inference algorithm to annotate types with explanations and is designed to produce succinct, non-repetitive explanations with minimal reference to artefacts of mechanized type inference.},
	pages = {436--452},
	journaltitle = {Comput. J.},
	shortjournal = {Comput. J.},
	author = {Jun, Yang and Michaelson, Greg and Trinder, Phil},
	year = {2002},
	date = {2002-04-01},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\VEKVMTQD\\Jun et al. - 2002 - Explaining Polymorphic Types.pdf:application/pdf},
}

@article{chen_counter-factual_2014,
	title = {Counter-factual typing for debugging type errors},
	volume = {49},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/2578855.2535863},
	doi = {10.1145/2578855.2535863},
	abstract = {Changing a program in response to a type error plays an important part in modern software development. However, the generation of good type error messages remains a problem for highly expressive type systems. Existing approaches often suffer from a lack of precision in locating errors and proposing remedies. Specifically, they either fail to locate the source of the type error consistently, or they report too many potential error locations. Moreover, the change suggestions offered are often incorrect. This makes the debugging process tedious and ineffective. We present an approach to the problem of type debugging that is based on generating and filtering a comprehensive set of type-change suggestions. Specifically, we generate all (program-structure-preserving) type changes that can possibly fix the type error. These suggestions will be ranked and presented to the programmer in an iterative fashion. In some cases we also produce suggestions to change the program. In most situations, this strategy delivers the correct change suggestions quickly, and at the same time never misses any rare suggestions. The computation of the potentially huge set of type-change suggestions is efficient since it is based on a variational type inference algorithm that type checks a program with variations only once, efficiently reusing type information for shared parts. We have evaluated our method and compared it with previous approaches. Based on a large set of examples drawn from the literature, we have found that our method outperforms other approaches and provides a viable alternative.},
	pages = {583--594},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Chen, Sheng and Erwig, Martin},
	urldate = {2022-12-01},
	year = {2014},
	date = {2014-01-08},
	keywords = {type inference, change suggestions, choice types, error localization, type error messages, type-error debugging},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\TURJCNGE\\Chen and Erwig - 2014 - Counter-factual typing for debugging type errors.pdf:application/pdf},
}

@inproceedings{hudak_history_2007,
	location = {New York, {NY}, {USA}},
	title = {A history of Haskell: being lazy with class},
	isbn = {978-1-59593-766-7},
	url = {https://doi.org/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	series = {{HOPL} {III}},
	shorttitle = {A history of Haskell},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	pages = {12--1--12--55},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on History of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	urldate = {2022-11-30},
	year = {2007},
	date = {2007-06-09},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\Y35DCS9K\\Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@inproceedings{jbara_how_2015,
	title = {How Programmers Read Regular Code: A Controlled Experiment Using Eye Tracking},
	doi = {10.1109/ICPC.2015.35},
	shorttitle = {How Programmers Read Regular Code},
	abstract = {Regular code, which includes repetitions of the same basic pattern, has been shown to have an effect on code comprehension: a regular function can be just as easy to comprehend as an irregular one with the same functionality, despite being longer and including more control constructs. It has been speculated that this effect is due to leveraging the understanding of the first instances to ease the understanding of repeated instances of the pattern. To verify and quantify this effect, we use eye tracking to measure the time and effort spent reading and understanding regular code. The results are that time and effort invested in the initial code segments are indeed much larger than those spent on the later ones, and the decay in effort can be modeled by an exponential or cubic model. This shows that syntactic code complexity metrics (such as {LOC} and {MCC}) need to be made context-sensitive, e.g. By giving reduced weight to repeated segments according to their place in the sequence.},
	eventtitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	pages = {244--254},
	booktitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	author = {Jbara, Ahmad and Feitelson, Dror G.},
	year = {2015},
	date = {2015-05},
	note = {{ISSN}: 1092-8138},
	keywords = {Visualization, Code complexity metrics, Code regularity, Complexity theory, Controlled experiment, Correlation, Diamonds, Eye tracking, Time measurement, Tracking},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\sfuu0016\\Zotero\\storage\\I8FHQVAY\\7181453.html:text/html},
}

@inproceedings{ko_finding_2009,
	location = {New York, {NY}, {USA}},
	title = {Finding causes of program output with the Java Whyline},
	isbn = {978-1-60558-246-7},
	url = {https://doi.org/10.1145/1518701.1518942},
	doi = {10.1145/1518701.1518942},
	series = {{CHI} '09},
	abstract = {Debugging and diagnostic tools are some of the most important software development tools, but most expect developers choose the right code to inspect. Unfortunately, this rarely occurs. A new tool called the Whyline is described which avoids such speculation by allowing developers to select questions about a program's output. The tool then helps developers work backwards from output to its causes. The prototype, which supports Java programs, was evaluated in an experiment in which participants investigated two real bug reports from an open source project using either the Whyline or a breakpoint debugger. Whyline users were successful about three times as often and about twice as fast compared to the control group, and were extremely positive about the tool's ability to simplify diagnostic tasks in software development work.},
	pages = {1569--1578},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Ko, Amy J. and Myers, Brad A.},
	urldate = {2022-11-30},
	year = {2009},
	date = {2009-04-04},
	keywords = {debugging, instrumentation, slicing, whyline},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\HM3JWRZ7\\Ko and Myers - 2009 - Finding causes of program output with the Java Why.pdf:application/pdf},
}

@inproceedings{lerner_searching_2007,
	location = {New York, {NY}, {USA}},
	title = {Searching for type-error messages},
	isbn = {978-1-59593-633-2},
	url = {https://doi.org/10.1145/1250734.1250783},
	doi = {10.1145/1250734.1250783},
	series = {{PLDI} '07},
	abstract = {Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.},
	pages = {425--434},
	booktitle = {Proceedings of the 28th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
	urldate = {2022-11-30},
	year = {2007},
	date = {2007-06-10},
	keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\88Z8PFLS\\Lerner et al. - 2007 - Searching for type-error messages.pdf:application/pdf},
}

@inproceedings{stuckey_interactive_2003,
	location = {Uppsala, Sweden},
	title = {Interactive type debugging in Haskell},
	isbn = {978-1-58113-758-3},
	url = {http://portal.acm.org/citation.cfm?doid=871895.871903},
	doi = {10.1145/871895.871903},
	eventtitle = {the {ACM} {SIGPLAN} workshop},
	pages = {72--83},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} workshop on Haskell  - Haskell '03},
	publisher = {{ACM} Press},
	author = {Stuckey, Peter J. and Sulzmann, Martin and Wazny, Jeremy},
	urldate = {2022-12-01},
	year = {2003},
	date = {2003},
	langid = {english},
	file = {Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\V2Z9NGRQ\\Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:application/pdf},
}

@article{haack_type_2004,
	title = {Type error slicing in implicitly typed higher-order languages},
	volume = {50},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S016764230400005X},
	doi = {10.1016/j.scico.2004.01.004},
	series = {12th European Symposium on Programming ({ESOP} 2003)},
	abstract = {Previous methods have generally identified the location of a type error as a particular program point or the program subtree rooted at that point. We present a new approach that identifies the location of a type error as a set of program points (a slice) all of which are necessary for the type error. We identify the criteria of completeness and minimality for type error slices. We discuss the advantages of complete and minimal type error slices over previous methods of presenting type errors. We present and prove the correctness of algorithms for finding complete and minimal type error slices for implicitly typed higher-order languages like Standard {ML}.},
	pages = {189--224},
	number = {1},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Haack, Christian and Wells, J. B.},
	urldate = {2022-12-01},
	year = {2004},
	date = {2004-03-01},
	langid = {english},
	keywords = {Intersection types, Type error location, Type inference},
	file = {Full Text:C\:\\Users\\sfuu0016\\Zotero\\storage\\5E6RNCET\\Haack and Wells - 2004 - Type error slicing in implicitly typed higher-orde.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\V96IFGKJ\\S016764230400005X.html:text/html},
}

@article{chargueraud_improving_2015,
	title = {Improving Type Error Messages in {OCaml}},
	volume = {198},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1512.01897},
	doi = {10.4204/EPTCS.198.4},
	pages = {80--97},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	shortjournal = {Electron. Proc. Theor. Comput. Sci.},
	author = {Charguéraud, Arthur},
	urldate = {2022-11-30},
	year = {2015},
	date = {2015-12-05},
	langid = {english},
	file = {Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\7KEJUBV9\\Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:application/pdf},
}

@inproceedings{marceau_measuring_2011,
	location = {New York, {NY}, {USA}},
	title = {Measuring the effectiveness of error messages designed for novice programmers},
	isbn = {978-1-4503-0500-6},
	url = {https://doi.org/10.1145/1953163.1953308},
	doi = {10.1145/1953163.1953308},
	series = {{SIGCSE} '11},
	abstract = {Good error messages are critical for novice programmers. Re-cognizing this, the {DrRacket} programming environment provides a series of pedagogically-inspired language subsets with error messages customized to each subset. We apply human-factors research methods to explore the effectiveness of these messages. Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a course-worth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages.},
	pages = {499--504},
	booktitle = {Proceedings of the 42nd {ACM} technical symposium on Computer science education},
	publisher = {Association for Computing Machinery},
	author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
	urldate = {2022-11-30},
	year = {2011},
	date = {2011-03-09},
	keywords = {novice programmers, error messages, user-studies},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\LYWM4QJT\\Marceau et al. - 2011 - Measuring the effectiveness of error messages desi.pdf:application/pdf},
}

@incollection{chatley_next_2019,
	location = {Cham},
	title = {The Next 7000 Programming Languages},
	isbn = {978-3-319-91908-9},
	url = {https://doi.org/10.1007/978-3-319-91908-9_15},
	series = {Lecture Notes in Computer Science},
	abstract = {Landin’s seminal paper “The next 700 programming languages” considered programming languages prior to 1966 and speculated on the next 700. Half-a-century on, we cast programming languages in a Darwinian ‘tree of life’ and explore languages, their features (genes) and language evolution from the viewpoint of ‘survival of the fittest’.},
	pages = {250--282},
	booktitle = {Computing and Software Science: State of the Art and Perspectives},
	publisher = {Springer International Publishing},
	author = {Chatley, Robert and Donaldson, Alastair and Mycroft, Alan},
	editor = {Steffen, Bernhard and Woeginger, Gerhard},
	urldate = {2022-11-30},
	year = {2019},
	date = {2019},
	langid = {english},
	doi = {10.1007/978-3-319-91908-9_15},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\56KYG6HT\\Chatley et al. - 2019 - The Next 7000 Programming Languages.pdf:application/pdf},
}

@inproceedings{kleinschmager_static_2012,
	title = {Do static type systems improve the maintainability of software systems? An empirical study},
	doi = {10.1109/ICPC.2012.6240483},
	shorttitle = {Do static type systems improve the maintainability of software systems?},
	abstract = {Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems influence human software development capabilities remains an open question. One frequently mentioned argument for static type systems is that they improve the maintainability of software systems - an often used claim for which there is no empirical evidence. This paper describes an experiment which tests whether static type systems improve the maintainability of software systems. The results show rigorous empirical evidence that static type are indeed beneficial to these activities, except for fixing semantic errors.},
	eventtitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	pages = {153--162},
	booktitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	author = {Kleinschmager, Sebastian and Robbes, Romain and Stefik, Andreas and Hanenberg, Stefan and Tanter, Eric},
	year = {2012},
	date = {2012-06},
	note = {{ISSN}: 1092-8138},
	keywords = {Java, Time measurement, Educational institutions, Programming, Semantics, Software},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\sfuu0016\\Zotero\\storage\\VQA4IKX9\\6240483.html:text/html;Submitted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\UDDAJWWA\\Kleinschmager et al. - 2012 - Do static type systems improve the maintainability.pdf:application/pdf},
}

@inproceedings{tsushima_type_2021,
	location = {New York, {NY}, {USA}},
	title = {Type debugging with counter-factual type error messages using an existing type checker},
	isbn = {978-1-4503-7562-7},
	url = {https://doi.org/10.1145/3412932.3412939},
	doi = {10.1145/3412932.3412939},
	series = {{IFL} '19},
	abstract = {The cause of a type error can be very difficult to find for the Hindley-Milner type system. Consequently many solutions have been proposed, but they are hardly used in practice. Here we propose a new solution that provides counter-factual type error messages; these messages state what types specific subexpressions in a program should have (in contrast to the types they actually have) to remove a type error. Such messages are easy-to-understand, because programers are already familiar with them. Furthermore, our solution is easy-to-implement, because it reuses an existing type checker as a subroutine. We transform an ill-typed program into a well-typed program with additional λ-bound variables. The types of these λ-bound variables yield actual and counter-factual type information. That type information plus intended types added as type annotations direct the search of the type debugger.},
	pages = {1--12},
	booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
	publisher = {Association for Computing Machinery},
	author = {Tsushima, Kanae and Chitil, Olaf and Sharrad, Joanna},
	urldate = {2022-12-02},
	year = {2021},
	date = {2021-07-15},
	keywords = {hindley-milner type system, {OCaml}},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\NHM2TBSC\\Tsushima et al. - 2021 - Type debugging with counter-factual type error mes.pdf:application/pdf},
}

@inproceedings{yang_improved_2000,
	title = {Improved type error reporting},
	booktitle = {In Proceedings of 12th International Workshop on Implementation of Functional Languages},
	publisher = {Citeseer},
	author = {Yang, Jun and Michaelson, Greg and Trinder, Phil and Wells, Joseph Brian},
	year = {2000},
	date = {2000},
	file = {Yang et al. - 2000 - Improved type error reporting.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\KCKI7Y6P\\Yang et al. - 2000 - Improved type error reporting.pdf:application/pdf},
}

@inproceedings{schilling_constraint-free_2012,
	location = {Berlin, Heidelberg},
	title = {Constraint-Free Type Error Slicing},
	isbn = {978-3-642-32037-8},
	doi = {10.1007/978-3-642-32037-8_1},
	series = {Lecture Notes in Computer Science},
	abstract = {Type error messages for {ML}-based languages tend to suffer from imprecise error locations – the type checker reports only one of many possible locations of an error. The notion of a type error slice corrects this by reporting all program locations that contribute to a given error (and no more).},
	pages = {1--16},
	booktitle = {Trends in Functional Programming},
	publisher = {Springer},
	author = {Schilling, Thomas},
	editor = {Peña, Ricardo and Page, Rex},
	year = {2012},
	date = {2012},
	langid = {english},
	keywords = {Error Message, Source Program, Syntactic Category, Type Error, Type Variable},
}

@inproceedings{wang_empirical_2015,
	title = {An empirical study on the impact of Python dynamic features on change-proneness},
	doi = {10.18293/SEKE2015-097},
	pages = {134--139},
	author = {Wang, Beibei and Chen, Lin and Ma, Wanwangying and Chen, Zhifei and Xu, Baowen},
	year = {2015},
	date = {2015-07-01},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\QQ8UG334\\Wang et al. - 2015 - An empirical study on the impact of Python dynamic.pdf:application/pdf},
}

@inproceedings{xu_python_2016,
	location = {New York, {NY}, {USA}},
	title = {Python predictive analysis for bug detection},
	isbn = {978-1-4503-4218-6},
	url = {https://doi.org/10.1145/2950290.2950357},
	doi = {10.1145/2950290.2950357},
	series = {{FSE} 2016},
	abstract = {Python is a popular dynamic language that allows quick software development. However, Python program analysis engines are largely lacking. In this paper, we present a Python predictive analysis. It first collects the trace of an execution, and then encodes the trace and unexecuted branches to symbolic constraints. Symbolic variables are introduced to denote input values, their dynamic types, and attribute sets, to reason about their variations. Solving the constraints identifies bugs and their triggering inputs. Our evaluation shows that the technique is highly effective in analyzing real-world complex programs with a lot of dynamic features and external library calls, due to its sophisticated encoding design based on traces. It identifies 46 bugs from 11 real-world projects, with 16 new bugs. All reported bugs are true positives.},
	pages = {121--132},
	booktitle = {Proceedings of the 2016 24th {ACM} {SIGSOFT} International Symposium on Foundations of Software Engineering},
	publisher = {Association for Computing Machinery},
	author = {Xu, Zhaogui and Liu, Peng and Zhang, Xiangyu and Xu, Baowen},
	urldate = {2022-12-04},
	year = {2016},
	date = {2016-11-01},
	keywords = {Python, Debugging, Dynamic Language, Predictive Analysis},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\6QVX45QA\\Xu et al. - 2016 - Python predictive analysis for bug detection.pdf:application/pdf},
}

@article{ray_large-scale_2017,
	title = {A large-scale study of programming languages and code quality in {GitHub}},
	volume = {60},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3126905},
	doi = {10.1145/3126905},
	abstract = {What is the effect of programming languages on software quality? This question has been a topic of much debate for a very long time. In this study, we gather a very large data set from {GitHub} (728 projects, 63 million {SLOC}, 29,000 authors, 1.5 million commits, in 17 languages) in an attempt to shed some empirical light on this question. This reasonably large sample size allows us to use a mixed-methods approach, combining multiple regression modeling with visualization and text analytics, to study the effect of language features such as static versus dynamic typing and allowing versus disallowing type confusion on software quality. By triangulating findings from different methods, and controlling for confounding effects such as team size, project size, and project history, we report that language design does have a significant, but modest effect on software quality. Most notably, it does appear that disallowing type confusion is modestly better than allowing it, and among functional languages, static typing is also somewhat better than dynamic typing. We also find that functional languages are somewhat better than procedural languages. It is worth noting that these modest effects arising from language design are overwhelmingly dominated by the process factors such as project size, team size, and commit size. However, we caution the reader that even these modest effects might quite possibly be due to other, intangible process factors, for example, the preference of certain personality types for functional, static languages that disallow type confusion.},
	pages = {91--100},
	number = {10},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Ray, Baishakhi and Posnett, Daryl and Devanbu, Premkumar and Filkov, Vladimir},
	urldate = {2022-12-05},
	year = {2017},
	date = {2017-09-25},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\RIRXSPMD\\Ray et al. - 2017 - A large-scale study of programming languages and c.pdf:application/pdf},
}

@inproceedings{meyerovich_empirical_2013,
	location = {New York, {NY}, {USA}},
	title = {Empirical analysis of programming language adoption},
	isbn = {978-1-4503-2374-1},
	url = {https://doi.org/10.1145/2509136.2509515},
	doi = {10.1145/2509136.2509515},
	series = {{OOPSLA} '13},
	abstract = {Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 {SourceForge} projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.},
	pages = {1--18},
	booktitle = {Proceedings of the 2013 {ACM} {SIGPLAN} international conference on Object oriented programming systems languages \& applications},
	publisher = {Association for Computing Machinery},
	author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
	urldate = {2022-12-04},
	year = {2013},
	date = {2013-10-29},
	keywords = {programming language adoption, survey research},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\PSJXKLZZ\\Meyerovich and Rabkin - 2013 - Empirical analysis of programming language adoptio.pdf:application/pdf},
}

@inproceedings{gao_type_2017,
	title = {To Type or Not to Type: Quantifying Detectable Bugs in {JavaScript}},
	doi = {10.1109/ICSE.2017.75},
	shorttitle = {To Type or Not to Type},
	abstract = {{JavaScript} is growing explosively and is now used in large mature projects even outside the web domain. {JavaScript} is also a dynamically typed language for which static type systems, notably Facebook's Flow and Microsoft's {TypeScript}, have been written. What benefits do these static type systems provide? Leveraging {JavaScript} project histories, we select a fixed bug and check out the code just prior to the fix. We manually add type annotations to the buggy code and test whether Flow and {TypeScript} report an error on the buggy code, thereby possibly prompting a developer to fix the bug before its public release. We then report the proportion of bugs on which these type systems reported an error. Evaluating static type systems against public bugs, which have survived testing and review, is conservative: it understates their effectiveness at detecting bugs during private development, not to mention their other benefits such as facilitating code search/completion and serving as documentation. Despite this uneven playing field, our central finding is that both static type systems find an important percentage of public bugs: both Flow 0.30 and {TypeScript} 2.0 successfully detect 15\%!.},
	eventtitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	pages = {758--769},
	booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
	author = {Gao, Zheng and Bird, Christian and Barr, Earl T.},
	year = {2017},
	date = {2017-05},
	note = {{ISSN}: 1558-1225},
	keywords = {Software, Computer bugs, Documentation, Facebook, Flow, History, {JavaScript}, Measurement uncertainty, mining software repositories, static type systems, Surgery, {TypeScript}},
	file = {Full Text:C\:\\Users\\sfuu0016\\Zotero\\storage\\DV88AQUU\\Gao et al. - 2017 - To Type or Not to Type Quantifying Detectable Bug.pdf:application/pdf;IEEE Xplore Abstract Record:C\:\\Users\\sfuu0016\\Zotero\\storage\\LGM3MNSZ\\7985711.html:text/html},
}

@inproceedings{mayer_empirical_2012,
	location = {New York, {NY}, {USA}},
	title = {An empirical study of the influence of static type systems on the usability of undocumented software},
	isbn = {978-1-4503-1561-6},
	url = {https://doi.org/10.1145/2384616.2384666},
	doi = {10.1145/2384616.2384666},
	series = {{OOPSLA} '12},
	abstract = {Abstract Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented {API} with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why.},
	pages = {683--702},
	booktitle = {Proceedings of the {ACM} international conference on Object oriented programming systems languages and applications},
	publisher = {Association for Computing Machinery},
	author = {Mayer, Clemens and Hanenberg, Stefan and Robbes, Romain and Tanter, Eric and Stefik, Andreas},
	urldate = {2022-12-04},
	year = {2012},
	date = {2012-10-19},
	keywords = {empirical research, programming languages, type systems},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\SL8KC92D\\Mayer et al. - 2012 - An empirical study of the influence of static type.pdf:application/pdf},
}

@online{haskell_haskell_nodate,
	title = {Haskell Extension for Visual Studio Code},
	url = {https://marketplace.visualstudio.com/items?itemName=haskell.haskell},
	author = {{Haskell}},
	urldate = {2022-12-12},
}

@online{microsoft_visual_nodate,
	title = {Visual Studio Code - Code Editing. Redefined},
	url = {https://code.visualstudio.com/},
	abstract = {Visual Studio Code is a code editor redefined and optimized for building and debugging modern web and cloud applications.  Visual Studio Code is free and available on your favorite platform - Linux, {macOS}, and Windows.},
	author = {{Microsoft}},
	urldate = {2022-12-12},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\K2PK87KP\\code.visualstudio.com.html:text/html},
}

@online{microsoft_javascript_nodate,
	title = {{JavaScript} With Syntax For Types.},
	url = {https://www.typescriptlang.org/},
	abstract = {{TypeScript} extends {JavaScript} by adding types to the language. {TypeScript} speeds up your development experience by catching errors and providing fixes before you even run your code.},
	author = {{Microsoft}},
	urldate = {2022-12-12},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\ZNXY8BRD\\www.typescriptlang.org.html:text/html},
}

@inproceedings{anonymous_interactive_2021,
	location = {Virtual},
	title = {Interactive Haskell Type Inference Exploration (Extended Abstract)},
	url = {https://icfp21.sigplan.org/details/TyDe-2021/6/Interactive-Haskell-Type-Inference-Exploration-Extended-Abstract-},
	eventtitle = {{ICFP} (Workshop on Type-Driven Development)},
	author = {{Fu, Shuai and Dwyer, Tim and Stuckey, Peter}},
	urldate = {2022-12-09},
	year = {2021},
	date = {2021},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\3QSIPE2H\\Interactive-Haskell-Type-Inference-Exploration-Extended-Abstract-.html:text/html},
}

@online{mypy_mypy_nodate,
	title = {mypy - Optional Static Typing for Python},
	url = {http://mypy-lang.org/},
	author = {{mypy}},
	urldate = {2022-12-07},
	file = {mypy - Optional Static Typing for Python:C\:\\Users\\sfuu0016\\Zotero\\storage\\8ALE9S5L\\mypy-lang.org.html:text/html},
}

@incollection{gaspers_improving_2017,
	location = {Cham},
	title = {Improving {MCS} Enumeration via Caching},
	volume = {10491},
	isbn = {978-3-319-66262-6 978-3-319-66263-3},
	url = {http://link.springer.com/10.1007/978-3-319-66263-3_12},
	abstract = {Enumeration of minimal correction sets ({MCSes}) of conjunctive normal form formulas is a central and highly intractable problem in infeasibility analysis of constraint systems. Often complete enumeration of {MCSes} is impossible due to both high computational cost and worst-case exponential number of {MCSes}. In such cases partial enumeration is sought for, ﬁnding applications in various domains, including axiom pinpointing in description logics among others. In this work we propose caching as a means of further improving the practical efﬁciency of current {MCS} enumeration approaches, and show the potential of caching via an empirical evaluation.},
	pages = {184--194},
	booktitle = {Theory and Applications of Satisfiability Testing – {SAT} 2017},
	publisher = {Springer International Publishing},
	author = {Previti, Alessandro and Mencía, Carlos and Järvisalo, Matti and Marques-Silva, Joao},
	editor = {Gaspers, Serge and Walsh, Toby},
	urldate = {2023-01-29},
	year = {2017},
	date = {2017},
	langid = {english},
	doi = {10.1007/978-3-319-66263-3_12},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Previti et al. - 2017 - Improving MCS Enumeration via Caching.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\MSR9DLS2\\Previti et al. - 2017 - Improving MCS Enumeration via Caching.pdf:application/pdf},
}

@article{loh_implementation_nodate,
	title = {An Implementation of a Dependently Typed Lambda Calculus},
	abstract = {We present an implementation in Haskell of a dependently-typed lambda calculus that can be used as the core of a programming language. We show that a dependently-typed lambda calculus is no more difﬁcult to implement than other typed lambda calculi. In fact, our implementation is almost as easy as an implementation of the simply typed lambda calculus, which we emphasize by discussing the modiﬁcations necessary to go from one to the other. We explain how to add data types and write simple programs in the core language, and discuss the steps necessary to build a full-ﬂedged programming language on top of our simple core.},
	author = {Loh, Andres and {McBride}, Conor and Swierstra, Wouter},
	langid = {english},
	file = {Loh et al. - An Implementation of a Dependently Typed Lambda Ca.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\4IZMJTDX\\Loh et al. - An Implementation of a Dependently Typed Lambda Ca.pdf:application/pdf},
}

@misc{ferdowsi_usability_2023,
	title = {The Usability of Advanced Type Systems: Rust as a Case Study},
	url = {http://arxiv.org/abs/2301.02308},
	shorttitle = {The Usability of Advanced Type Systems},
	abstract = {Advanced type systems that enforce various correctness and safety guarantees--such as linear and ownership types--have a long history in the Programming Languages research community. Despite this history, a human-centered evaluation of these type systems and their usability was all but absent, with empirical evaluations limited to testing their expressiveness in programs written by experts, i.e. the creators of the type system. In the past few years, this has begun to change with the adoption of a version of affine types and ownership in the popular Rust programming language. With the increase in Rust's popularity, various studies have begun empirically evaluating the usability of Rust's Ownership and Lifetime rules, providing a breadth of qualitative and quantitative information on the usability of such type systems. They found that despite Rust's general success in achieving its promise of safety and performance, these rules come with a steep learning curve and have been repeatedly cited as a barrier to adopting Rust. In this report, I provide a brief history of linear types and region-based memory management, which directly inspired Rust's type system. I then introduce Rust's Ownership and Lifetime rules, and present the state-of-the-art in academic research into their usability. I discuss both theoretical arguments and empirical evidence for why these rules are difficult to learn and apply, and survey existing work on addressing some of these difficulties. I also draw from broader works in the {HCI} and {CS} Education communities to recommend future work in this area.},
	number = {{arXiv}:2301.02308},
	publisher = {{arXiv}},
	author = {Ferdowsi, Kasra},
	urldate = {2023-02-23},
	year = {2023},
	date = {2023-01-05},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2301.02308 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Programming Languages},
	file = {Ferdowsi - 2023 - The Usability of Advanced Type Systems Rust as a .pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\JZUIHBZB\\2301.02308.pdf:application/pdf},
}
