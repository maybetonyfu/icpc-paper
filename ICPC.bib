
@article{crichton_role_2021,
	title = {The Role of Working Memory in Program Tracing},
	url = {http://arxiv.org/abs/2101.06305},
	doi = {10.1145/3411764.3445257},
	abstract = {Program tracing, or mentally simulating a program on concrete inputs, is an important part of general program comprehension. Programs involve many kinds of virtual state that must be held in memory, such as variable/value pairs and a call stack. In this work, we examine the influence of short-term working memory ({WM}) on a person's ability to remember program state during tracing. We first confirm that previous findings in cognitive psychology transfer to the programming domain: people can keep about 7 variable/value pairs in {WM}, and people will accidentally swap associations between variables due to {WM} load. We use a restricted focus viewing interface to further analyze the strategies people use to trace through programs, and the relationship of tracing strategy to {WM}. Given a straight-line program, we find half of our participants traced a program from the top-down line-by-line (linearly), and the other half start at the bottom and trace upward based on data dependencies (on-demand). Participants with an on-demand strategy made more {WM} errors while tracing straight-line code than with a linear strategy, but the two strategies contained an equal number of {WM} errors when tracing code with functions. We conclude with the implications of these findings for the design of programming tools: first, programs should be analyzed to identify and refactor human-memory-intensive sections of code. Second, programming environments should interactively visualize variable metadata to reduce {WM} load in accordance with a person's tracing strategy. Third, tools for program comprehension should enable externalizing program state while tracing.},
	journaltitle = {{arXiv}:2101.06305 [cs]},
	author = {Crichton, Will and Agrawala, Maneesh and Hanrahan, Pat},
	urldate = {2021-01-20},
	date = {2021-01-15},
	eprinttype = {arxiv},
	eprint = {2101.06305},
	keywords = {Computer Science - Human-Computer Interaction},
	file = {arXiv Fulltext PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\X68EQS9A\\Crichton et al. - 2021 - The Role of Working Memory in Program Tracing.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\W4XUTN47\\2101.html:text/html},
}

@inproceedings{becker_effective_2016,
	location = {Memphis Tennessee {USA}},
	title = {An Effective Approach to Enhancing Compiler Error Messages},
	isbn = {978-1-4503-3685-7},
	url = {https://dl.acm.org/doi/10.1145/2839509.2844584},
	doi = {10.1145/2839509.2844584},
	abstract = {One of the many challenges novice programmers face from the time they write their ﬁrst program is inadequate compiler error messages. These messages report details on errors the programmer has made and are the only feedback the programmer gets from the compiler. For students they play a particularly essential role as students often have little experience to draw upon, leaving compiler error messages as their primary guidance on error correction. However these messages are frequently inadequate, presenting a barrier to progress and are often a source of discouragement. We have designed and implemented an editor that provides enhanced compiler error messages and conducted a controlled empirical study with {CS}1 students learning Java. We ﬁnd a reduced frequency of overall errors and errors per student. We also identify eight frequent compiler error messages for which enhancement has a statistically signiﬁcant eﬀect. Finally we ﬁnd a reduced number of repeated errors. These ﬁndings indicate fewer students struggling with compiler error messages.},
	eventtitle = {{SIGCSE} '16: The 47th {ACM} Technical Symposium on Computing Science Education},
	pages = {126--131},
	booktitle = {Proceedings of the 47th {ACM} Technical Symposium on Computing Science Education},
	publisher = {{ACM}},
	author = {Becker, Brett A.},
	urldate = {2021-05-21},
	date = {2016-02-17},
	langid = {english},
	file = {Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\YS373YTK\\Becker - 2016 - An Effective Approach to Enhancing Compiler Error .pdf:application/pdf},
}

@inproceedings{barik_how_2018,
	title = {How should compilers explain problems to developers?},
	pages = {633--643},
	booktitle = {Proceedings of the 2018 26th {ACM} Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
	author = {Barik, Titus and Ford, Denae and Murphy-Hill, Emerson and Parnin, Chris},
	date = {2018},
	file = {barik_fse18.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\J76K3M45\\barik_fse18.pdf:application/pdf},
}

@inproceedings{hartmann_what_2010,
	location = {New York, {NY}, {USA}},
	title = {What would other programmers do: suggesting solutions to error messages},
	isbn = {978-1-60558-929-9},
	url = {https://doi.org/10.1145/1753326.1753478},
	doi = {10.1145/1753326.1753478},
	series = {{CHI} '10},
	shorttitle = {What would other programmers do},
	abstract = {Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces {HelpMeOut}, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. {HelpMeOut} comprises {IDE} instrumentation to collect examples of code changes that fix errors; a central database that stores fix reports from many users; and a suggestion interface that, given an error, queries the database for a list of relevant fixes and presents these to the programmer. We report on implementations of this architecture for two programming languages. An evaluation with novice programmers found that the technique can suggest useful fixes for 47\% of errors after 39 person-hours of programming in an instrumented environment.},
	pages = {1019--1028},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Hartmann, Björn and {MacDougall}, Daniel and Brandt, Joel and Klemmer, Scott R.},
	urldate = {2022-11-27},
	date = {2010-04-10},
	keywords = {debugging, recommender systems},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\DZHWAZNI\\Hartmann et al. - 2010 - What would other programmers do suggesting soluti.pdf:application/pdf},
}

@inproceedings{uchida_c-helper_2016,
	location = {Setubal, {PRT}},
	title = {C-Helper: C Latent-error Static/Heuristic Checker for Novice Programmers},
	isbn = {978-989-758-179-3},
	url = {https://doi.org/10.5220/0005797703210329},
	doi = {10.5220/0005797703210329},
	series = {{CSEDU} 2016},
	shorttitle = {C-Helper},
	abstract = {For better programming language education, it is crucial to make compiler warning messages more understandable for novice programmers. Unfortunately, however, Kojimaâ s research showed warning messages in commercial-level compilers like {GCC} are still difficult to understand, and the commercial-level compilers tend not to emit how to modify programs to correct the problems. Furthermore, we found that they also tend not to handle latent errors. To solve this problem, by using a heuristic approach, we propose a novel C static checker called C-Helper, that aims to emit more direct error messages understandable for novices to correct wrong programs, and also aims to handle latent errors. Our preliminary evaluation shows that C-Helper was positively evaluated, although our heuristic approach increased false-positives.},
	pages = {321--329},
	booktitle = {Proceedings of the 8th International Conference on Computer Supported Education},
	publisher = {{SCITEPRESS} - Science and Technology Publications, Lda},
	author = {Uchida, Kota and Gondow, Katsuhiko},
	urldate = {2022-11-28},
	date = {2016-04-21},
	keywords = {C Static Checker, Compiler Warning Messages, Heuristics, Latent Errors, Novice Programmer., Programming Education},
	file = {Submitted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\4CP9WV5Z\\Uchida and Gondow - 2016 - C-Helper C Latent-error StaticHeuristic Checker .pdf:application/pdf},
}

@inproceedings{watson_bluefix_2012,
	location = {Berlin, Heidelberg},
	title = {{BlueFix}: Using Crowd-Sourced Feedback to Support Programming Students in Error Diagnosis and Repair},
	isbn = {978-3-642-33642-3},
	doi = {10.1007/978-3-642-33642-3_25},
	series = {Lecture Notes in Computer Science},
	shorttitle = {{BlueFix}},
	abstract = {Feedback is regarded as one of the most important influences on student learning and motivation. But standard compiler feedback is designed for experts - not novice programming students, who can find it difficult to interpret and understand. In this paper we present {BlueFix}, an online tool currently integrated into the {BlueJ} {IDE} which is designed to assist programming students with error diagnosis and repair. Unlike existing approaches, {BlueFix} proposes a feedback algorithm based upon frameworks combined from the {HCI} and Pedagogical domains, which can provide different students with dynamic levels of support based upon their compilation behaviour. An evaluation revealed that students’ viewed our tool positively and that our methodology could identify appropriate fixes for uncompilable source code with a significantly higher rate of speed and precision over related techniques in the literature.},
	pages = {228--239},
	booktitle = {Advances in Web-Based Learning - {ICWL} 2012},
	publisher = {Springer},
	author = {Watson, Christopher and Li, Frederick W. B. and Godwin, Jamie L.},
	editor = {Popescu, Elvira and Li, Qing and Klamma, Ralf and Leung, Howard and Specht, Marcus},
	date = {2012},
	langid = {english},
	keywords = {Programming Education, Compiler Errors, Crowd Fixes, Feedback},
	file = {Accepted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\XXB27MDH\\Watson et al. - 2012 - BlueFix Using Crowd-Sourced Feedback to Support P.pdf:application/pdf},
}

@article{wu_how_2017,
	title = {How type errors were fixed and what students did?},
	volume = {1},
	url = {https://doi.org/10.1145/3133929},
	doi = {10.1145/3133929},
	abstract = {Providing better supports for debugging type errors has been an active research area in the last three decades. Numerous approaches from different perspectives have been developed. Most approaches work well under certain conditions only, for example, when type errors are caused by single leaves and when type annotations are correct. However, the research community is still unaware of which conditions hold in practice and what the real debugging situations look like. We address this problem with a study of 3 program data sets, which were written in different years, using different compilers, and were of diverse sizes. They include more than 55,000 programs, among which more than 2,700 are ill typed. We investigated all the ill-typed programs, and our results indicate that current error debugging support is far from sufficient in practice since only about 35\% of all type errors were caused by single leaves. In addition, type annotations cannot always be trusted in error debuggers since about 30\% of the time type errors were caused by wrong type annotations. Our study also provides many insights about the debugging behaviors of students in functional programming, which could be exploited for developing more effective error debuggers.},
	pages = {105:1--105:27},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Wu, Baijun and Chen, Sheng},
	urldate = {2022-11-28},
	date = {2017-10-12},
	keywords = {type inference, empirical study, Type-error debugging},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\2WB5DVYJ\\Wu and Chen - 2017 - How type errors were fixed and what students did.pdf:application/pdf},
}

@article{chen_efficient_2020,
	title = {Efficient counter-factual type error debugging},
	volume = {200},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642320301520},
	doi = {10.1016/j.scico.2020.102544},
	abstract = {Providing effective error messages in response to type errors continues to be a challenge in functional programming. Type error messages often point to bogus error locations or lack sufficient information for removing the type error, making error debugging ineffective. Counter-factual typing ({CFT}) addressed this problem by generating comprehensive error messages with each message includes a rich set of information. However, this comes with a cost of huge computations, making it too slow for interactive use. In particular, our recent study shows that programmers usually have to go through multiple iterations of updating and recompiling programs to remove a type error. Interestingly, our study also finds that program updates are minor in each iteration during type error debugging. We exploit this fact and develop {eCFT}, an efficient version of {CFT}, which doesn't recompute all error fixes from scratch for each updated program but only recomputes error fixes that are changed in response to the update. Our key observation is that minor program changes lead to minor error suggestion changes. {eCFT} is based on principal typing, a typing scheme more amenable to reuse previous typing results. We have evaluated our approach and found it is about 12.4× faster than {CFT} in updating error fixes.},
	pages = {102544},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Chen, Sheng and Wu, Baijun},
	urldate = {2022-11-28},
	date = {2020-12-01},
	langid = {english},
	keywords = {Efficient type-error debugging, Principal typing, Variational typing},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\YSRLHV7Q\\Chen and Wu - 2020 - Efficient counter-factual type error debugging.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\RATV7C6T\\S0167642320301520.html:text/html},
}

@inproceedings{potter_hazel_2020,
	title = {Hazel Tutor: Guiding Novices Through Type-Driven Development Strategies},
	eventtitle = {Human Aspects of Types and Reasoning Assistants},
	pages = {10},
	author = {Potter, Hannah and Omar, Cyrus},
	date = {2020},
	langid = {english},
	file = {Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\NWG4MUL7\\Potter and Omar - Hazel Tutor Guiding Novices Through Type-Driven D.pdf:application/pdf},
}

@misc{leinonen_using_2022,
	title = {Using Large Language Models to Enhance Programming Error Messages},
	url = {http://arxiv.org/abs/2210.11630},
	doi = {10.48550/arXiv.2210.11630},
	abstract = {A key part of learning to program is learning to understand programming error messages. They can be hard to interpret and identifying the cause of errors can be time-consuming. One factor in this challenge is that the messages are typically intended for an audience that already knows how to program, or even for programming environments that then use the information to highlight areas in code. Researchers have been working on making these errors more novice friendly since the 1960s, however progress has been slow. The present work contributes to this stream of research by using large language models to enhance programming error messages with explanations of the errors and suggestions on how to fix the error. Large language models can be used to create useful and novice-friendly enhancements to programming error messages that sometimes surpass the original programming error messages in interpretability and actionability. These results provide further evidence of the benefits of large language models for computing educators, highlighting their use in areas known to be challenging for students. We further discuss the benefits and downsides of large language models and highlight future streams of research for enhancing programming error messages.},
	number = {{arXiv}:2210.11630},
	publisher = {{arXiv}},
	author = {Leinonen, Juho and Hellas, Arto and Sarsa, Sami and Reeves, Brent and Denny, Paul and Prather, James and Becker, Brett A.},
	urldate = {2022-11-28},
	date = {2022-10-20},
	eprinttype = {arxiv},
	eprint = {2210.11630 [cs]},
	keywords = {Computer Science - Human-Computer Interaction, Computer Science - Artificial Intelligence, Computer Science - Computation and Language, Computer Science - Software Engineering},
	file = {arXiv Fulltext PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\AWNXRMLQ\\Leinonen et al. - 2022 - Using Large Language Models to Enhance Programming.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\H5BUETBU\\2210.html:text/html},
}

@inproceedings{prather_novices_2017,
	location = {New York, {NY}, {USA}},
	title = {On Novices' Interaction with Compiler Error Messages: A Human Factors Approach},
	isbn = {978-1-4503-4968-0},
	url = {https://doi.org/10.1145/3105726.3106169},
	doi = {10.1145/3105726.3106169},
	series = {{ICER} '17},
	shorttitle = {On Novices' Interaction with Compiler Error Messages},
	abstract = {The difficulty in understanding compiler error messages can be a major impediment to novice student learning. To alleviate this issue, multiple researchers have run experiments enhancing compiler error messages in automated assessment tools for programming assignments. The conclusions reached by these published experiments appear to be conducting. We examine these experiments and propose five potential reasons for the inconsistent conclusions concerning enhanced compiler error messages: (1) students do not read them, (2) researchers are measuring the wrong thing, (3) the effects are hard to measure, (4) the messages are not properly designed, (5) the messages are properly designed, but students do not understand them in context due to increased cognitive load. We constructed mixed-methods experiments designed to address reasons 1 and 5 with a specific automated assessment tool, Athene, that previously reported inconclusive results. Testing student comprehension of the enhanced compiler error messages outside the context of an automated assessment tool demonstrated their effectiveness over standard compiler error messages. Quantitative results from a 60 minute one-on-one think-aloud study with 31 students did not show substantial increase in student learning outcomes over the control. However, qualitative results from the one-on-one think-aloud study indicated that most students are reading the enhanced compiler error messages and generally make effective changes after encountering them.},
	pages = {74--82},
	booktitle = {Proceedings of the 2017 {ACM} Conference on International Computing Education Research},
	publisher = {Association for Computing Machinery},
	author = {Prather, James and Pettit, Raymond and {McMurry}, Kayla Holcomb and Peters, Alani and Homer, John and Simone, Nevan and Cohen, Maxine},
	urldate = {2022-11-28},
	date = {2017-08-14},
	keywords = {{CS}1, {HCI}, automated assessment tools, education, ethnography, human factors, usability},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\FYLNZ4FY\\Prather et al. - 2017 - On Novices' Interaction with Compiler Error Messag.pdf:application/pdf},
}

@inproceedings{barik_developers_2017,
	location = {Buenos Aires, Argentina},
	title = {Do developers read compiler error messages?},
	isbn = {978-1-5386-3868-2},
	url = {https://doi.org/10.1109/ICSE.2017.59},
	doi = {10.1109/ICSE.2017.59},
	series = {{ICSE} '17},
	abstract = {In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and graduate software engineering courses at our university. The participants attempted to resolve common, yet problematic defects in a Java code base within the Eclipse development environment. We found that: 1) participants read error messages and the difficulty of reading these messages is comparable to the difficulty of reading source code, 2) difficulty reading error messages significantly predicts participants' task performance, and 3) participants allocate a substantial portion of their total task to reading error messages (13\%--25\%). The results of our study offer empirical justification for the need to improve compiler error messages for developers.},
	pages = {575--585},
	booktitle = {Proceedings of the 39th International Conference on Software Engineering},
	publisher = {{IEEE} Press},
	author = {Barik, Titus and Smith, Justin and Lubick, Kevin and Holmes, Elisabeth and Feng, Jing and Murphy-Hill, Emerson and Parnin, Chris},
	urldate = {2022-11-28},
	date = {2017-05-20},
	keywords = {compiler errors, eye tracking, integrated development environments, programmer comprehension, reading, visual attention},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\QZMS6ZMH\\Barik et al. - 2017 - Do developers read compiler error messages.pdf:application/pdf},
}

@inproceedings{chen_empirical_2020,
	location = {New York, {NY}, {USA}},
	title = {An Empirical Study on Dynamic Typing Related Practices in Python Systems},
	isbn = {978-1-4503-7958-8},
	url = {https://doi.org/10.1145/3387904.3389253},
	doi = {10.1145/3387904.3389253},
	series = {{ICPC} '20},
	abstract = {The dynamic typing discipline of Python allows developers to program at a high level of abstraction. However, type related bugs are commonly encountered in Python systems due to the lack of type declaration and static type checking. Especially, the misuse of dynamic typing discipline produces underlying bugs and increases maintenance efforts. In this paper, we introduce six types of dynamic typing related practices in Python programs, which are the common but potentially risky usage of dynamic typing discipline by developers. We also implement a tool named {PYDYPE} to detect them. Based on this tool, we conduct an empirical study on nine real-world Python systems (with the size of more than 460KLOC) to understand dynamic typing related practices. We investigate how widespread the dynamic typing related practices are, why they are introduced into the systems, whether their usage correlates with increased likelihood of bug occurring, and how developers fix dynamic typing related bugs. The results show that: (1) dynamic typing related practices exist inconsistently in different systems and Inconsistent Variable Types is most prevalent; (2) they are introduced into systems mainly during early development phase to promote development efficiency; (3) they have a significant positive correlation with bug occurring; (4) developers tend to add type checks or exception handling to fix dynamic typing related bugs. These results benefit future research in coding convention, language design, bug detection and fixing.},
	pages = {83--93},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {Association for Computing Machinery},
	author = {Chen, Zhifei and Li, Yanhui and Chen, Bihuan and Ma, Wanwangying and Chen, Lin and Xu, Baowen},
	urldate = {2022-11-28},
	date = {2020-09-12},
	keywords = {empirical study, dynamic typing, Python},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\B5GFRWHC\\Chen et al. - 2020 - An Empirical Study on Dynamic Typing Related Pract.pdf:application/pdf},
}

@inproceedings{peitek_what_2020,
	location = {Seoul Republic of Korea},
	title = {What Drives the Reading Order of Programmers?: An Eye Tracking Study},
	isbn = {978-1-4503-7958-8},
	url = {https://dl.acm.org/doi/10.1145/3387904.3389279},
	doi = {10.1145/3387904.3389279},
	shorttitle = {What Drives the Reading Order of Programmers?},
	abstract = {Background: The way how programmers comprehend source code depends on several factors, including the source code itself and the programmer. Recent studies showed that novice programmers tend to read source code more like natural language text, whereas experts tend to follow the program execution flow. But, it is unknown how the linearity of source code and the comprehension strategy influence programmers’ linearity of reading order.},
	eventtitle = {{ICPC} '20: 28th International Conference on Program Comprehension},
	pages = {342--353},
	booktitle = {Proceedings of the 28th International Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Peitek, Norman and Siegmund, Janet and Apel, Sven},
	urldate = {2022-11-28},
	date = {2020-07-13},
	langid = {english},
	file = {Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\5P68H8QU\\Peitek et al. - 2020 - What Drives the Reading Order of Programmers An .pdf:application/pdf},
}

@inproceedings{tymchuk_jit_2018,
	location = {Gothenburg Sweden},
	title = {{JIT} feedback: what experienced developers like about static analysis},
	isbn = {978-1-4503-5714-2},
	url = {https://dl.acm.org/doi/10.1145/3196321.3196327},
	doi = {10.1145/3196321.3196327},
	shorttitle = {{JIT} feedback},
	abstract = {Although software developers are usually reluctant to use static analysis to detect issues in their source code, our automatic justin-time static analysis assistant was integrated into an Integrated Development Environment, and was evaluated positively by its users. We conducted interviews to understand the impact of the tool on experienced developers, and how it performs in comparison with other static analyzers.},
	eventtitle = {{ICSE} '18: 40th International Conference on Software Engineering},
	pages = {64--73},
	booktitle = {Proceedings of the 26th Conference on Program Comprehension},
	publisher = {{ACM}},
	author = {Tymchuk, Yuriy and Ghafari, Mohammad and Nierstrasz, Oscar},
	urldate = {2022-11-28},
	date = {2018-05-28},
	langid = {english},
	file = {Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\UPLMXZNT\\Tymchuk et al. - 2018 - JIT feedback what experienced developers like abo.pdf:application/pdf},
}

@article{tirronen_understanding_2015,
	title = {Understanding beginners' mistakes with Haskell},
	volume = {25},
	issn = {0956-7968, 1469-7653},
	doi = {10.1017/S0956796815000179},
	abstract = {This article presents an overview of student difficulties in an introductory functional programming ({FP}) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to {FP} languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
	pages = {e11},
	journaltitle = {Journal of Functional Programming},
	author = {Tirronen, Ville and Uusi-Mäkelä, Samuel and Isomöttönen, Ville},
	urldate = {2022-11-30},
	date = {2015},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\CVGTHT3I\\Tirronen et al. - 2015 - Understanding beginners' mistakes with Haskell.pdf:application/pdf;Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\PX3IZ8M4\\244DB6807F3BD77E14CE7D627514D6D3.html:text/html},
}

@book{jakob_nielsen_usability_1993,
	title = {Usability Engineering},
	publisher = {Morgan Kaufmann},
	author = {{Jakob Nielsen}},
	date = {1993},
}

@online{stackoverflow_stack_2022,
	title = {Stack Overflow Developer Survey 2022},
	url = {https://survey.stackoverflow.co/2022/},
	abstract = {In May 2022 over 70,000 developers told us how they learn and level up, which tools they’re using, and what they want.},
	titleaddon = {Stack Overflow},
	author = {{StackOverflow}},
	urldate = {2022-11-30},
	date = {2022},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\6JVDBGSQ\\2022.html:text/html},
}

@online{github_github_2022,
	title = {{GitHub} Topic: Haskell},
	url = {https://github.com/topics/haskell},
	abstract = {{GitHub} is where people build software. More than 94 million people use {GitHub} to discover, fork, and contribute to over 330 million projects.},
	titleaddon = {{GitHub}},
	author = {{Github}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
	file = {Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\I9YMPF7L\\haskell.html:text/html},
}

@inproceedings{chen_improving_2022,
	location = {Cham},
	title = {Improving Type Error Reporting for Type Classes},
	isbn = {978-3-030-99461-7},
	doi = {10.1007/978-3-030-99461-7_2},
	series = {Lecture Notes in Computer Science},
	abstract = {Debugging type errors when type inference fails is a challenging problem since there are many different ways to remove the type error, and it’s unclear which way is intended. While numerous approaches have been proposed to more precisely locate the real error causes, most of them do not deal with popular type system extensions, such as type classes. A second problem is that most approaches do not provide enough information for removing the type error or do so for a few error causes only.},
	pages = {19--38},
	booktitle = {Functional and Logic Programming},
	publisher = {Springer International Publishing},
	author = {Chen, Sheng and Noor, Md Rabib},
	editor = {Hanus, Michael and Igarashi, Atsushi},
	date = {2022},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\S49WNG7Q\\Chen and Noor - 2022 - Improving Type Error Reporting for Type Classes.pdf:application/pdf},
}

@online{openreplay_openreplay_2022,
	title = {{OpenReplay}: Open-Source Session Replay},
	url = {https://openreplay.com/},
	author = {{OpenReplay}},
	urldate = {2022-12-01},
	date = {2022},
}

@online{oracle_generic_2022,
	title = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials {\textgreater} Learning the Java Language {\textgreater} Generics (Updated))},
	url = {https://docs.oracle.com/javase/tutorial/java/generics/boundedTypeParams.html},
	author = {{Oracle}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Generic Methods and Bounded Type Parameters (The Java™ Tutorials > Learning the Java Language > Generics (Updated)):C\:\\Users\\sfuu0016\\Zotero\\storage\\N4IGCP5E\\boundedTypeParams.html:text/html},
}

@online{bill_wagner_constraints_2022,
	title = {Constraints on type parameters - C\# Programming Guide},
	url = {https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters},
	abstract = {Learn about constraints on type parameters. Constraints tell the compiler what capabilities a type argument must have.},
	author = {{Bill Wagner}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
}

@inproceedings{pavlinovic_practical_2015,
	location = {New York, {NY}, {USA}},
	title = {Practical {SMT}-based type error localization},
	isbn = {978-1-4503-3669-7},
	url = {https://doi.org/10.1145/2784731.2784765},
	doi = {10.1145/2784731.2784765},
	series = {{ICFP} 2015},
	abstract = {Compilers for statically typed functional programming languages are notorious for generating confusing type error messages. When the compiler detects a type error, it typically reports the program location where the type checking failed as the source of the error. Since other error sources are not even considered, the actual root cause is often missed. A more adequate approach is to consider all possible error sources and report the most useful one subject to some usefulness criterion. In our previous work, we showed that this approach can be formulated as an optimization problem related to satisfiability modulo theories ({SMT}). This formulation cleanly separates the heuristic nature of usefulness criteria from the underlying search problem. Unfortunately, algorithms that search for an optimal error source cannot directly use principal types which are crucial for dealing with the exponential-time complexity of the decision problem of polymorphic type checking. In this paper, we present a new algorithm that efficiently finds an optimal error source in a given ill-typed program. Our algorithm uses an improved {SMT} encoding to cope with the high complexity of polymorphic typing by iteratively expanding the typing constraints from which principal types are derived. The algorithm preserves the clean separation between the heuristics and the actual search. We have implemented our algorithm for {OCaml}. In our experimental evaluation, we found that the algorithm reduces the running times for optimal type error localization from minutes to seconds and scales better than previous localization algorithms.},
	pages = {412--423},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on Functional Programming},
	publisher = {Association for Computing Machinery},
	author = {Pavlinovic, Zvonimir and King, Tim and Wies, Thomas},
	urldate = {2022-12-02},
	date = {2015-08-29},
	keywords = {Polymorphic Types, Satisfiability Modulo Theories, Type Error Localization},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\DT9YHB5D\\Pavlinovic et al. - 2015 - Practical SMT-based type error localization.pdf:application/pdf},
}

@online{microsoft_documentation_2022,
	title = {Documentation - Generics},
	url = {https://www.typescriptlang.org/docs/handbook/2/generics.html},
	abstract = {Types which take parameters},
	author = {{Microsoft}},
	urldate = {2022-12-01},
	date = {2022},
	langid = {english},
}

@online{shuai_fu_chameleon_2022,
	title = {Chameleon Type Debugger},
	url = {https://chameleon.typecheck.me/},
	author = {{Shuai Fu}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Chameleon Type Debugger:C\:\\Users\\sfuu0016\\Zotero\\storage\\7ABZKGSA\\chameleon.typecheck.me.html:text/html},
}

@online{ben_gamari_home_2022,
	title = {Home — The Glasgow Haskell Compiler},
	url = {https://www.haskell.org/ghc/},
	author = {{Ben Gamari}},
	urldate = {2022-12-01},
	date = {2022},
	file = {Home — The Glasgow Haskell Compiler:C\:\\Users\\sfuu0016\\Zotero\\storage\\KQPULY88\\ghc.html:text/html},
}

@article{mayer_static_2012,
	title = {Static Type Systems (Sometimes) have a Positive Impact on the Usability of Undocumented Software: An Empirical Evaluation},
	abstract = {Static and dynamic type systems (as well as more recently gradual type systems) are an important research topic in programming language design. Although the study of such systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease ﬂexibility, which may make them harder to use. While positions such as these, both for and against static type systems, have been documented in the literature, there is little rigorous empirical evidence for or against either position. In this paper, we introduce a controlled experiment where 27 subjects performed programming tasks on an undocumented {API} with a static type system (which required type annotations) as well as a dynamic type system (which does not). Our results show that for some types of tasks, programmers were afforded faster task completion times using a static type system, while for others, the opposite held. In this work, we document the empirical evidence that led us to this conclusion and conduct an exploratory study to try and theorize why.},
	pages = {20},
	author = {Mayer, Clemens and Robbes, Romain and Tanter, Éric and Steﬁk, Andreas},
	date = {2012},
	langid = {english},
	file = {Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\PR85XC8Y\\Mayer et al. - Static Type Systems (Sometimes) have a Positive Im.pdf:application/pdf},
}

@article{jun_explaining_2002,
	title = {Explaining Polymorphic Types},
	volume = {45},
	doi = {10.1093/comjnl/45.4.436},
	abstract = {Polymorphic types in programming languages facilitate code reuse, increase reliability and reduce semantic errors in programs. Hindley-Milner type inference forms a strong basis for checking polymorphic types but is less well suited to explaining them, as it introduces intermediate constructs that relate poorly to a programmer’s understanding of the program. We report an experiment into expert human type explanation and uncover a simple set of rules for human-like explanations. We present a type explanation system based on these rules rather than Hindley-Milner inference. The system uses a new ℋ inference algorithm to annotate types with explanations and is designed to produce succinct, non-repetitive explanations with minimal reference to artefacts of mechanized type inference.},
	pages = {436--452},
	journaltitle = {Comput. J.},
	shortjournal = {Comput. J.},
	author = {Jun, Yang and Michaelson, Greg and Trinder, Phil},
	date = {2002-04-01},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\VEKVMTQD\\Jun et al. - 2002 - Explaining Polymorphic Types.pdf:application/pdf},
}

@article{chen_counter-factual_2014,
	title = {Counter-factual typing for debugging type errors},
	volume = {49},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/2578855.2535863},
	doi = {10.1145/2578855.2535863},
	abstract = {Changing a program in response to a type error plays an important part in modern software development. However, the generation of good type error messages remains a problem for highly expressive type systems. Existing approaches often suffer from a lack of precision in locating errors and proposing remedies. Specifically, they either fail to locate the source of the type error consistently, or they report too many potential error locations. Moreover, the change suggestions offered are often incorrect. This makes the debugging process tedious and ineffective. We present an approach to the problem of type debugging that is based on generating and filtering a comprehensive set of type-change suggestions. Specifically, we generate all (program-structure-preserving) type changes that can possibly fix the type error. These suggestions will be ranked and presented to the programmer in an iterative fashion. In some cases we also produce suggestions to change the program. In most situations, this strategy delivers the correct change suggestions quickly, and at the same time never misses any rare suggestions. The computation of the potentially huge set of type-change suggestions is efficient since it is based on a variational type inference algorithm that type checks a program with variations only once, efficiently reusing type information for shared parts. We have evaluated our method and compared it with previous approaches. Based on a large set of examples drawn from the literature, we have found that our method outperforms other approaches and provides a viable alternative.},
	pages = {583--594},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Chen, Sheng and Erwig, Martin},
	urldate = {2022-12-01},
	date = {2014-01-08},
	keywords = {type inference, change suggestions, choice types, error localization, type error messages, type-error debugging},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\TURJCNGE\\Chen and Erwig - 2014 - Counter-factual typing for debugging type errors.pdf:application/pdf},
}

@inproceedings{hudak_history_2007,
	location = {New York, {NY}, {USA}},
	title = {A history of Haskell: being lazy with class},
	isbn = {978-1-59593-766-7},
	url = {https://doi.org/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	series = {{HOPL} {III}},
	shorttitle = {A history of Haskell},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	pages = {12--1--12--55},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on History of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	urldate = {2022-11-30},
	date = {2007-06-09},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\Y35DCS9K\\Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@inproceedings{jbara_how_2015,
	title = {How Programmers Read Regular Code: A Controlled Experiment Using Eye Tracking},
	doi = {10.1109/ICPC.2015.35},
	shorttitle = {How Programmers Read Regular Code},
	abstract = {Regular code, which includes repetitions of the same basic pattern, has been shown to have an effect on code comprehension: a regular function can be just as easy to comprehend as an irregular one with the same functionality, despite being longer and including more control constructs. It has been speculated that this effect is due to leveraging the understanding of the first instances to ease the understanding of repeated instances of the pattern. To verify and quantify this effect, we use eye tracking to measure the time and effort spent reading and understanding regular code. The results are that time and effort invested in the initial code segments are indeed much larger than those spent on the later ones, and the decay in effort can be modeled by an exponential or cubic model. This shows that syntactic code complexity metrics (such as {LOC} and {MCC}) need to be made context-sensitive, e.g. By giving reduced weight to repeated segments according to their place in the sequence.},
	eventtitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	pages = {244--254},
	booktitle = {2015 {IEEE} 23rd International Conference on Program Comprehension},
	author = {Jbara, Ahmad and Feitelson, Dror G.},
	date = {2015-05},
	note = {{ISSN}: 1092-8138},
	keywords = {Visualization, Code complexity metrics, Code regularity, Complexity theory, Controlled experiment, Correlation, Diamonds, Eye tracking, Time measurement, Tracking},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\sfuu0016\\Zotero\\storage\\I8FHQVAY\\7181453.html:text/html},
}

@inproceedings{ko_finding_2009,
	location = {New York, {NY}, {USA}},
	title = {Finding causes of program output with the Java Whyline},
	isbn = {978-1-60558-246-7},
	url = {https://doi.org/10.1145/1518701.1518942},
	doi = {10.1145/1518701.1518942},
	series = {{CHI} '09},
	abstract = {Debugging and diagnostic tools are some of the most important software development tools, but most expect developers choose the right code to inspect. Unfortunately, this rarely occurs. A new tool called the Whyline is described which avoids such speculation by allowing developers to select questions about a program's output. The tool then helps developers work backwards from output to its causes. The prototype, which supports Java programs, was evaluated in an experiment in which participants investigated two real bug reports from an open source project using either the Whyline or a breakpoint debugger. Whyline users were successful about three times as often and about twice as fast compared to the control group, and were extremely positive about the tool's ability to simplify diagnostic tasks in software development work.},
	pages = {1569--1578},
	booktitle = {Proceedings of the {SIGCHI} Conference on Human Factors in Computing Systems},
	publisher = {Association for Computing Machinery},
	author = {Ko, Amy J. and Myers, Brad A.},
	urldate = {2022-11-30},
	date = {2009-04-04},
	keywords = {debugging, instrumentation, slicing, whyline},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\HM3JWRZ7\\Ko and Myers - 2009 - Finding causes of program output with the Java Why.pdf:application/pdf},
}

@inproceedings{lerner_searching_2007,
	location = {New York, {NY}, {USA}},
	title = {Searching for type-error messages},
	isbn = {978-1-59593-633-2},
	url = {https://doi.org/10.1145/1250734.1250783},
	doi = {10.1145/1250734.1250783},
	series = {{PLDI} '07},
	abstract = {Advanced type systems often need some form of type inference to reduce the burden of explicit typing, but type inference often leads to poor error messages for ill-typed programs. This work pursues a new approach to constructing compilers and presenting type-error messages in which the type-checker itself does not produce the messages. Instead, it is an oracle for a search procedure that finds similar programs that do type-check. Our two-fold goal is to improve error messages while simplifying compiler construction. Our primary implementation and evaluation is for Caml, a language with full type inference. We also present a prototype for C++ template functions, where type instantiation is implicit. A key extension is making our approach robust even when the program has multiple independent type errors.},
	pages = {425--434},
	booktitle = {Proceedings of the 28th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Lerner, Benjamin S. and Flower, Matthew and Grossman, Dan and Chambers, Craig},
	urldate = {2022-11-30},
	date = {2007-06-10},
	keywords = {error messages, objective Caml, seminal, type-checking, type-inference},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\88Z8PFLS\\Lerner et al. - 2007 - Searching for type-error messages.pdf:application/pdf},
}

@inproceedings{stuckey_interactive_2003,
	location = {Uppsala, Sweden},
	title = {Interactive type debugging in Haskell},
	isbn = {978-1-58113-758-3},
	url = {http://portal.acm.org/citation.cfm?doid=871895.871903},
	doi = {10.1145/871895.871903},
	eventtitle = {the {ACM} {SIGPLAN} workshop},
	pages = {72--83},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} workshop on Haskell  - Haskell '03},
	publisher = {{ACM} Press},
	author = {Stuckey, Peter J. and Sulzmann, Martin and Wazny, Jeremy},
	urldate = {2022-12-01},
	date = {2003},
	langid = {english},
	file = {Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\V2Z9NGRQ\\Stuckey et al. - 2003 - Interactive type debugging in Haskell.pdf:application/pdf},
}

@article{haack_type_2004,
	title = {Type error slicing in implicitly typed higher-order languages},
	volume = {50},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S016764230400005X},
	doi = {10.1016/j.scico.2004.01.004},
	series = {12th European Symposium on Programming ({ESOP} 2003)},
	abstract = {Previous methods have generally identified the location of a type error as a particular program point or the program subtree rooted at that point. We present a new approach that identifies the location of a type error as a set of program points (a slice) all of which are necessary for the type error. We identify the criteria of completeness and minimality for type error slices. We discuss the advantages of complete and minimal type error slices over previous methods of presenting type errors. We present and prove the correctness of algorithms for finding complete and minimal type error slices for implicitly typed higher-order languages like Standard {ML}.},
	pages = {189--224},
	number = {1},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Haack, Christian and Wells, J. B.},
	urldate = {2022-12-01},
	date = {2004-03-01},
	langid = {english},
	keywords = {Intersection types, Type error location, Type inference},
	file = {Full Text:C\:\\Users\\sfuu0016\\Zotero\\storage\\5E6RNCET\\Haack and Wells - 2004 - Type error slicing in implicitly typed higher-orde.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\V96IFGKJ\\S016764230400005X.html:text/html},
}

@article{chargueraud_improving_2015,
	title = {Improving Type Error Messages in {OCaml}},
	volume = {198},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1512.01897},
	doi = {10.4204/EPTCS.198.4},
	pages = {80--97},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	shortjournal = {Electron. Proc. Theor. Comput. Sci.},
	author = {Charguéraud, Arthur},
	urldate = {2022-11-30},
	date = {2015-12-05},
	langid = {english},
	file = {Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\7KEJUBV9\\Charguéraud - 2015 - Improving Type Error Messages in OCaml.pdf:application/pdf},
}

@inproceedings{marceau_measuring_2011,
	location = {New York, {NY}, {USA}},
	title = {Measuring the effectiveness of error messages designed for novice programmers},
	isbn = {978-1-4503-0500-6},
	url = {https://doi.org/10.1145/1953163.1953308},
	doi = {10.1145/1953163.1953308},
	series = {{SIGCSE} '11},
	abstract = {Good error messages are critical for novice programmers. Re-cognizing this, the {DrRacket} programming environment provides a series of pedagogically-inspired language subsets with error messages customized to each subset. We apply human-factors research methods to explore the effectiveness of these messages. Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors. We present a rubric (which is not language specific) to evaluate student responses, apply it to a course-worth of student lab work, and describe what we have learned about using the rubric effectively. We also discuss some concrete observations on the effectiveness of these messages.},
	pages = {499--504},
	booktitle = {Proceedings of the 42nd {ACM} technical symposium on Computer science education},
	publisher = {Association for Computing Machinery},
	author = {Marceau, Guillaume and Fisler, Kathi and Krishnamurthi, Shriram},
	urldate = {2022-11-30},
	date = {2011-03-09},
	keywords = {novice programmers, error messages, user-studies},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\LYWM4QJT\\Marceau et al. - 2011 - Measuring the effectiveness of error messages desi.pdf:application/pdf},
}

@incollection{chatley_next_2019,
	location = {Cham},
	title = {The Next 7000 Programming Languages},
	isbn = {978-3-319-91908-9},
	url = {https://doi.org/10.1007/978-3-319-91908-9_15},
	series = {Lecture Notes in Computer Science},
	abstract = {Landin’s seminal paper “The next 700 programming languages” considered programming languages prior to 1966 and speculated on the next 700. Half-a-century on, we cast programming languages in a Darwinian ‘tree of life’ and explore languages, their features (genes) and language evolution from the viewpoint of ‘survival of the fittest’.},
	pages = {250--282},
	booktitle = {Computing and Software Science: State of the Art and Perspectives},
	publisher = {Springer International Publishing},
	author = {Chatley, Robert and Donaldson, Alastair and Mycroft, Alan},
	editor = {Steffen, Bernhard and Woeginger, Gerhard},
	urldate = {2022-11-30},
	date = {2019},
	langid = {english},
	doi = {10.1007/978-3-319-91908-9_15},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\56KYG6HT\\Chatley et al. - 2019 - The Next 7000 Programming Languages.pdf:application/pdf},
}

@inproceedings{kleinschmager_static_2012,
	title = {Do static type systems improve the maintainability of software systems? An empirical study},
	doi = {10.1109/ICPC.2012.6240483},
	shorttitle = {Do static type systems improve the maintainability of software systems?},
	abstract = {Static type systems play an essential role in contemporary programming languages. Despite their importance, whether static type systems influence human software development capabilities remains an open question. One frequently mentioned argument for static type systems is that they improve the maintainability of software systems - an often used claim for which there is no empirical evidence. This paper describes an experiment which tests whether static type systems improve the maintainability of software systems. The results show rigorous empirical evidence that static type are indeed beneficial to these activities, except for fixing semantic errors.},
	eventtitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	pages = {153--162},
	booktitle = {2012 20th {IEEE} International Conference on Program Comprehension ({ICPC})},
	author = {Kleinschmager, Sebastian and Robbes, Romain and Stefik, Andreas and Hanenberg, Stefan and Tanter, Eric},
	date = {2012-06},
	note = {{ISSN}: 1092-8138},
	keywords = {Java, Time measurement, Educational institutions, Programming, Semantics, Software},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\sfuu0016\\Zotero\\storage\\VQA4IKX9\\6240483.html:text/html;Submitted Version:C\:\\Users\\sfuu0016\\Zotero\\storage\\UDDAJWWA\\Kleinschmager et al. - 2012 - Do static type systems improve the maintainability.pdf:application/pdf},
}

@inproceedings{tsushima_type_2021,
	location = {New York, {NY}, {USA}},
	title = {Type debugging with counter-factual type error messages using an existing type checker},
	isbn = {978-1-4503-7562-7},
	url = {https://doi.org/10.1145/3412932.3412939},
	doi = {10.1145/3412932.3412939},
	series = {{IFL} '19},
	abstract = {The cause of a type error can be very difficult to find for the Hindley-Milner type system. Consequently many solutions have been proposed, but they are hardly used in practice. Here we propose a new solution that provides counter-factual type error messages; these messages state what types specific subexpressions in a program should have (in contrast to the types they actually have) to remove a type error. Such messages are easy-to-understand, because programers are already familiar with them. Furthermore, our solution is easy-to-implement, because it reuses an existing type checker as a subroutine. We transform an ill-typed program into a well-typed program with additional λ-bound variables. The types of these λ-bound variables yield actual and counter-factual type information. That type information plus intended types added as type annotations direct the search of the type debugger.},
	pages = {1--12},
	booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
	publisher = {Association for Computing Machinery},
	author = {Tsushima, Kanae and Chitil, Olaf and Sharrad, Joanna},
	urldate = {2022-12-02},
	date = {2021-07-15},
	keywords = {hindley-milner type system, {OCaml}},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\NHM2TBSC\\Tsushima et al. - 2021 - Type debugging with counter-factual type error mes.pdf:application/pdf},
}

@inproceedings{yang_improved_2000,
	title = {Improved type error reporting},
	booktitle = {In Proceedings of 12th International Workshop on Implementation of Functional Languages},
	publisher = {Citeseer},
	author = {Yang, Jun and Michaelson, Greg and Trinder, Phil and Wells, Joseph Brian},
	date = {2000},
	file = {Yang et al. - 2000 - Improved type error reporting.pdf:C\:\\Users\\sfuu0016\\Zotero\\storage\\KCKI7Y6P\\Yang et al. - 2000 - Improved type error reporting.pdf:application/pdf},
}

@inproceedings{schilling_constraint-free_2012,
	location = {Berlin, Heidelberg},
	title = {Constraint-Free Type Error Slicing},
	isbn = {978-3-642-32037-8},
	doi = {10.1007/978-3-642-32037-8_1},
	series = {Lecture Notes in Computer Science},
	abstract = {Type error messages for {ML}-based languages tend to suffer from imprecise error locations – the type checker reports only one of many possible locations of an error. The notion of a type error slice corrects this by reporting all program locations that contribute to a given error (and no more).},
	pages = {1--16},
	booktitle = {Trends in Functional Programming},
	publisher = {Springer},
	author = {Schilling, Thomas},
	editor = {Peña, Ricardo and Page, Rex},
	date = {2012},
	langid = {english},
	keywords = {Error Message, Source Program, Syntactic Category, Type Error, Type Variable},
}

@article{tirronen_understanding_2015-1,
	title = {Understanding beginners' mistakes with Haskell},
	volume = {25},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/understanding-beginners-mistakes-with-haskell/244DB6807F3BD77E14CE7D627514D6D3},
	doi = {10.1017/S0956796815000179},
	abstract = {This article presents an overview of student difficulties in an introductory functional programming ({FP}) course taught in Haskell. The motivation for this study stems from our belief that many student difficulties can be alleviated by understanding the underlying causes of errors and by modifying the educational approach and, possibly, the teaching language accordingly. We analyze students' exercise submissions and categorize student errors according to compiler error messages and then manually according to the observed underlying cause. Our study complements earlier studies on the topic by applying computer and manual analysis while focusing on providing descriptive statistics of difficulties specific to {FP} languages. We conclude that the majority of student errors, regardless of cause, are reported by three different compiler error messages that are not well understood by students. In addition, syntactic features, such as precedence, the syntax of function application, and deeply nested statements, cause difficulties throughout the course.},
	pages = {e11},
	journaltitle = {Journal of Functional Programming},
	author = {Tirronen, Ville and Uusi-Mäkelä, Samuel and Isomöttönen, Ville},
	urldate = {2022-12-04},
	date = {2015},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:C\:\\Users\\sfuu0016\\Zotero\\storage\\U7MS9SCB\\Tirronen et al. - 2015 - Understanding beginners' mistakes with Haskell.pdf:application/pdf;Snapshot:C\:\\Users\\sfuu0016\\Zotero\\storage\\TFWL3SXM\\244DB6807F3BD77E14CE7D627514D6D3.html:text/html},
}
